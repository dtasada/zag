diff --git a/src/compiler/Compiler.zig b/src/compiler/Compiler.zig
index 2fdded0..db2027b 100644
--- a/src/compiler/Compiler.zig
+++ b/src/compiler/Compiler.zig
@@ -803,8 +803,6 @@ pub fn registerSymbol(
         constant: struct { type: Type, value: Value },
     },
 ) !void {
-    std.debug.print("registering symbol: '{s}'\n", .{name});
-    try @import("pretty").print(self.alloc, symbol_or_type, .{});
     var last = &self.scopes.items[self.scopes.items.len - 1];
     try last.put(name, switch (symbol_or_type) {
         .symbol => |symbol| .{
diff --git a/src/compiler/Type.zig b/src/compiler/Type.zig
index 1c83c7e..afddcb9 100644
--- a/src/compiler/Type.zig
+++ b/src/compiler/Type.zig
@@ -381,14 +381,14 @@ pub const Type = union(enum) {
             }
 
             const new_type: Type = switch (def_wrap) {
-                .@"struct" => |d| blk: {
-                    var copy = d.*;
-                    copy.name = name;
-                    copy.generic_types = null;
-                    var t = try fromCompoundTypeDeclaration(compiler, .@"struct", &copy);
+                .@"struct" => |s| blk: {
+                    var copy_decl = try s.clone(compiler.alloc);
+                    copy_decl.generic_types = null;
+
+                    var t = try fromCompoundTypeDeclaration(compiler, .@"struct", &copy_decl);
                     t.generic_instantiation = .{
                         .base_name = base_name,
-                        .args = try compiler.alloc.dupe(Value, args.items),
+                        .args = args.items,
                     };
                     break :blk .{ .@"struct" = t };
                 },
@@ -650,9 +650,9 @@ pub const Type = union(enum) {
             .@"enum" => Type.Enum,
         } = if (compiler.getSymbolType(type_decl.name)) |existing| b: {
             switch (T) {
-                .@"struct" => if (existing == .@"struct") break :b existing.@"struct",
-                .@"union" => if (existing == .@"union") break :b existing.@"union",
-                .@"enum" => if (existing == .@"enum") break :b existing.@"enum",
+                .@"struct" => if (existing == .@"struct" and existing.@"struct".definition != null) break :b existing.@"struct",
+                .@"union" => if (existing == .@"union" and existing.@"union".definition != null) break :b existing.@"union",
+                .@"enum" => if (existing == .@"enum" and existing.@"enum".definition != null) break :b existing.@"enum",
             }
             // If type mismatch or not found (logic error in scan?), create new.
             // But strict forward decl implies we should find it.
@@ -704,6 +704,8 @@ pub const Type = union(enum) {
             },
         });
 
+        std.debug.print("[ENTRY] Processing struct {s} at address {*}, members count: {}\n", .{ type_decl.name, &compound_type, compound_type.members.count() });
+
         // If definition is set, it means we already populated this type.
         if (compound_type.definition != null) return compound_type;
 
@@ -728,8 +730,6 @@ pub const Type = union(enum) {
             compound_type.tag_type = tag_t;
         }
 
-        compound_type.definition = type_decl;
-
         switch (T) {
             .@"struct", .@"union" => {
                 if (type_decl.generic_types) |generic_types| {
@@ -744,21 +744,60 @@ pub const Type = union(enum) {
             else => {},
         }
 
-        try compiler.registerSymbol(type_decl.name, .{ .type = @unionInit(Type, @tagName(T), compound_type) });
+        compound_type.definition = type_decl;
 
         try compiler.pushScope();
         defer compiler.popScope();
 
         switch (T) {
-            .@"struct", .@"union" => if (type_decl.generic_types) |generic_types| {
-                for (generic_types.items) |g|
-                    try compiler.registerSymbol(g.name, .{ .type = .{ .generic_param = g.name } });
+            .@"struct", .@"union" => {
+                if (type_decl.generic_types) |generic_types| {
+                    for (generic_types.items) |g| {
+                        try compiler.registerSymbol(g.name, .{ .type = .{ .generic_param = g.name } });
+                    }
+                }
+
+                // Register a PLACEHOLDER type with the correct generic params
+                const placeholder = switch (T) {
+                    .@"struct" => blk: {
+                        var s = try Type.Struct.init(compiler.alloc, type_decl.name, null);
+                        if (type_decl.generic_types) |gt| {
+                            s.generic_params = try std.ArrayList(Type.Function.Param).initCapacity(compiler.alloc, gt.items.len);
+                            for (gt.items) |param| {
+                                s.generic_params.appendAssumeCapacity(.{
+                                    .name = param.name,
+                                    .type = .type, // Generic params don't have concrete types
+                                });
+                            }
+                        }
+                        break :blk Type{ .@"struct" = s };
+                    },
+                    .@"union" => blk: {
+                        var u = try Type.Union.init(compiler.alloc, type_decl.name, null);
+                        if (type_decl.generic_types) |gt| {
+                            u.generic_params = try std.ArrayList(Type.Function.Param).initCapacity(compiler.alloc, gt.items.len);
+                            for (gt.items) |param| {
+                                u.generic_params.appendAssumeCapacity(.{
+                                    .name = param.name,
+                                    .type = .type,
+                                });
+                            }
+                        }
+                        break :blk Type{ .@"union" = u };
+                    },
+                    else => unreachable,
+                };
+
+                try compiler.registerSymbol(type_decl.name, .{ .type = placeholder });
             },
             else => {},
         }
 
+        std.debug.print("[BEFORE MEMBERS] Processing struct {s}, members count: {}\n", .{ type_decl.name, compound_type.members.count() });
+
         var enum_last_value: usize = 0;
         for (type_decl.members.items) |member| {
+            std.debug.print("  Adding member {s}\n", .{member.name});
             if (compound_type.getProperty(member.name)) |_| return utils.printErr(
                 error.DuplicateMember,
                 "comperr: Duplicate member '{s}' declared in '{s}' at {f}.\n",
diff --git a/src/parser/ast.zig b/src/parser/ast.zig
index ba35871..022b43c 100644
--- a/src/parser/ast.zig
+++ b/src/parser/ast.zig
@@ -287,6 +287,17 @@ pub const Statement = union(enum) {
         generic_types: ?ParameterList = null,
         members: std.ArrayList(Member) = .empty,
         methods: std.ArrayList(FunctionDefinition) = .empty,
+
+        pub fn clone(self: *const StructDeclaration, alloc: std.mem.Allocator) !StructDeclaration {
+            return .{
+                .pos = self.pos,
+                .is_pub = self.is_pub,
+                .name = self.name, // notice: doesn't clone the name.
+                .generic_types = if (self.generic_types) |gt| try gt.clone(alloc) else null,
+                .members = try self.members.clone(alloc),
+                .methods = try self.methods.clone(alloc),
+            };
+        }
     };
 
     pub const UnionDeclaration = struct {
