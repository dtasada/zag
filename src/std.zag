import c;

pub fn alloc<T>() !&mut T {
    let ptr = c.malloc(sizeof<T>());
    if (ptr == c_null) c.printf("error allocating");
    return ptr;
}

pub fn free<T>(ptr: &T) void {
    c.free(ptr);
}

pub fn free_slice<T>(slice: []mut T) void {
    c.free(cast<&mut void>(slice.ptr));
}

pub fn alloc_slice<T>(N: usize) []mut T {
    let mut slice: []mut T = undefined;
    slice.ptr = cast<&mut T>(c.malloc(sizeof<T>() * N));
    slice.len = N;
    return slice;
}

// Invalidates old `slice`
pub fn realloc_slice<T>(slice: []mut T, new_size: usize) []mut T {
    let mut new_slice: []mut T = undefined;
    new_slice.ptr = cast<&mut T>(c.realloc(cast<&mut void>(slice.ptr), new_size * sizeof<T>()));
    new_slice.len = new_size;
    return new_slice;
}

pub fn min<T>(a, b: T) T {
    return if (a > b) b else a;
}

pub fn max<T>(a, b: T) T {
    return if (a > b) a else b;
}

pub struct ArrayList<T> {
    items: []mut T,
    capacity: usize,

    pub fn init() ArrayList<T> {
        return ArrayList<T> {
            items: alloc_slice<T>(0),
            capacity: 16,
        };
    }

    fn ensure_capacity(self: &mut ArrayList<T>, min_cap: usize) void {
        if (self.capacity >= min_cap) return;

        let new_cap = max<usize>(min_cap, self.capacity * 2 + 1);

        let new_buf = if (self.capacity == 0)
            alloc_slice<T>(new_cap)
        else
            realloc_slice<T>(self.items[0..self.capacity], new_cap);

        self.items = new_buf[0..self.items.len];
        self.capacity = new_cap;
    }

    pub fn append(self: &mut ArrayList<T>, item: T) void {
        self.ensure_capacity(self.items.len + 1);
        self.items[self.items.len] = item;
        self.items = self.items[0..=self.items.len];
    }

    pub fn pop(self: &mut ArrayList<T>) ?T {
        if (self.items.len == 0) return null;

        let idx = self.items.len - 1;
        let val = self.items[idx];

        self.items = self.items[0..idx];
        return val;
    }


    pub fn clear(self: &mut ArrayList<T>) void {
        self.items = self.items[0..=0];
    }

    pub fn deinit(self: &mut ArrayList<T>) void {
        if (self.capacity != 0) {
            free_slice<T>(self.items[0..self.capacity]);
        }
    }
}
