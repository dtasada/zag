import c;

pub fn min<T>(a, b: T) T -> return if (a > b) b else a;
pub fn max<T>(a, b: T) T -> return if (a > b) a else b;

pub fn alloc<T>() !&mut T {
    let ptr = c.malloc(sizeof<T>());
    if (ptr == c_null) c.printf("error allocating");
    return ptr;
}

pub fn free<T>(ptr: &T) void -> c.free(ptr);

pub fn free_slice<T>(slice: []mut T) void -> c.free(cast<&mut void>(slice.ptr));

pub fn alloc_slice<T>(N: usize) []mut T {
    let mut slice: []mut T = undefined;
    slice.ptr = cast<&mut T>(c.malloc(sizeof<T>() * N));
    slice.len = N;
    return slice;
}

// Invalidates old slice
pub fn realloc_slice<T>(slice: []mut T, new_size: usize) []mut T {
    let mut new_slice: []mut T = undefined;
    new_slice.ptr = cast<&mut T>(c.realloc(cast<&mut void>(slice.ptr), new_size * sizeof<T>()));
    new_slice.len = new_size;
    return new_slice;
}

pub fn memcpy<T>(dst: &mut T, src: &T) void -> c.memcpy(cast<&mut void>(dst), cast<&void>(src), sizeof<T>());

pub fn memcpy_slice<T>(dst: []mut T, src: []T) !void {
    if (dst.len != src.len) return c_null;

    c.memcpy(cast<&mut void>(dst.ptr), cast<&void>(src.ptr), sizeof<T>() * dst.len);
}

pub fn memmove<T>(dst: []mut T, src: []T) !void {
    if (dst.len != src.len) return c_null;

    c.memmove(cast<&mut void>(dst.ptr), cast<&void>(src.ptr), sizeof<T>() * dst.len);
}

pub struct ArrayList<T> {
    let N = 3;

    items: []mut T,
    capacity: usize,

    pub fn init() ArrayList<T> {
        c.printf("N: %d\n", N);
        return ArrayList<T> {
            items: alloc_slice<T>(0),
            capacity: 0,
        };
    }

    fn ensure_capacity(self: &mut ArrayList<T>, min_cap: usize) void {
        if (self.capacity >= min_cap) return;

        let new_cap = max<usize>(min_cap, if (self.capacity == 0) 16 else self.capacity * 2);

        let new_buf = if (self.capacity == 0)
            alloc_slice<T>(new_cap)
        else
            // `realloc_slice` only cares about the pointer, so passing `self.items` is fine.
            realloc_slice<T>(self.items, new_cap);

        // The new buffer (`new_buf`) has length `new_cap`. We want our `items` slice
        // to point to this new buffer, but maintain its old logical length.
        self.items = new_buf[0..self.items.len];
        self.capacity = new_cap;
    }

    pub fn append(self: &mut ArrayList<T>, item: T) void {
        self.ensure_capacity(self.items.len + 1);
        
        // Correctly grow the slice's length by 1 by re-slicing from the base pointer.
        self.items = self.items[0..self.items.len + 1];
        
        // Assign the new item to the new last slot.
        self.items[self.items.len - 1] = item;
    }

    pub fn pop(self: &mut ArrayList<T>) ?T {
        if (self.items.len == 0) return null;

        let idx = self.items.len - 1;
        let val = self.items[idx];

        // Correctly shrink the slice by re-slicing.
        self.items = self.items[0..idx];
        return val;
    }


    pub fn clear(self: &mut ArrayList<T>) void {
        // Correctly set length to 0.
        self.items = self.items[..0];
    }

    pub fn deinit(self: &mut ArrayList<T>) void {
        if (self.capacity != 0)
            // To free the whole buffer, we must create a slice representing the full capacity.
            free_slice<T>(self.items[..self.capacity]);
    }

    pub fn contains(self: &ArrayList<T>, item: T) bool {
        for (self.items) |i| {
            if (item == i) return true;
        }

        return false;
    }

    pub fn eq(self: &ArrayList<T>, rhs: &ArrayList<T>) bool {
        if (self.items.len != rhs.items.len) return false;
        for (0..self.items.len) |i| {
            if (self.items[i] != rhs.items[i]) return false;
        }
        return true;
    }

    pub fn index_of(self: &ArrayList<T>, item: T) !usize {
        for (0..self.items.len) |i| {
            if (self.items[i] == item) return i;
        }

        return c_null;
    }

    pub fn last_index_of(self: &ArrayList<T>, item: T) !usize {
        if (self.items.len == 0) return c_null;
        for (self.items.len - 1..=0) |i| {
            if (self.items[i] == item) return i;
        }

        return c_null;
    }

    pub fn remove(self: &mut ArrayList<T>, index: usize) !void {
        if (index >= self.items.len) return c_null;

        if (index < self.items.len - 1) {
            // Only memmove if it's not the last element
            let src = self.items[index + 1..self.items.len];
            let dst = self.items[index .. self.items.len - 1];
            memmove<T>(dst, src);
        }
        
        // Correctly shrink the slice.
        self.items = self.items[0..self.items.len - 1];
    }
}
