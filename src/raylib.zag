import std;

const EPSILON = 0.000001;

// Vector2, 2 components
pub struct Vector2 {
    x: f32,                // Vector x component
    y: f32,                // Vector y component

    pub fn init(x, y: f32) Vector2 -> Vector2 { x: x, y: y }
    // Vector with components value 0.0f
    pub fn zero() Vector2 -> Vector2.init(0, 0)
    // Vector with components value 1.0f
    pub fn one() Vector2 -> Vector2.init(1, 1)
    // Add two vectors (v1 + v2)
    pub fn add(v1, v2: Vector2) Vector2 -> Vector2.init(v1.x + v2.x, v1.y + v2.y)
    // Add vector and float value
    pub fn add_value(v: Vector2, add: f32) Vector2 -> Vector2.init(v.x + add, v.y + add)
    // Subtract two vectors (v1 - v2)
    pub fn subtract(v1, v2: Vector2) Vector2 -> Vector2.init(v1.x - v2.x, v1.y - v2.y)
    // Subtract vector by float value
    pub fn subtract_value(v: Vector2, sub: f32) Vector2 -> Vector2.init(v.x - sub, v.y - sub)
    // Calculate vector length
    pub fn length(v: Vector2) f32 -> std.sqrt<f32>(v.length_sqr())
    // Calculate vector square length
    pub fn length_sqr(v: Vector2) f32 -> v.x*v.x + v.y*v.y
    // Calculate two vectors dot product
    pub fn dot_product(v1, v2: Vector2) f32 -> v1.x*v2.x + v1.y*v2.y
    // Calculate two vectors cross product
    pub fn cross_product(v1, v2: Vector2) f32 -> v1.x*v2.y - v1.y*v2.x
    // Calculate distance between two vectors
    pub fn distance(v1, v2: Vector2) f32 -> std.sqrt<f32>(v1.distance_sqr(v2))
    // Calculate square distance between two vectors
    pub fn distance_sqr(v1, v2: Vector2) f32 -> (v1.x - v2.x)*(v1.x - v2.x) + (v1.y - v2.y)*(v1.y - v2.y)
    // Calculate the signed angle from v1 to v2, relative to the origin (0, 0)
    // NOTE: Coordinate system convention: positive X right, positive Y down
    // positive angles appear clockwise, and negative angles appear counterclockwise
    pub fn angle(v1, v2: Vector2) f32 -> std.atan2<f32>(v1.x*v2.y - v1.y*v2.x, v1.x*v2.x + v1.y*v2.y)
    // Calculate angle defined by a two vectors line
    // NOTE: Parameters need to be normalized
    // Current implementation should be aligned with glm::angle
    pub fn line_angle(start, end: Vector2) f32 -> std.atan2<f32>(end.y - start.y, end.x - start.x)
    // Scale vector (multiply by value)
    pub fn scale(v: Vector2, scale: f32) Vector2 -> Vector2.init(v.x*scale, v.y*scale)
    // Multiply vector by vector
    pub fn multiply(v1, v2: Vector2) Vector2 -> Vector2.init(v1.x*v2.x, v1.y*v2.y)
    // Negate vector2
    pub fn negate(v: Vector2) Vector2 -> Vector2.init(-v.x, -v.y)
    // Divide vector by vector
    pub fn divide(v1, v2: Vector2) Vector2 -> Vector2.init(v1.x/v2.x, v1.y/v2.y)
    // Normalize provided vector
    pub fn normalize(v: Vector2) Vector2 -> if (v.length() > 0) v.scale(1.0 / v.length()) else v
    // Transforms a Vector2 by a given Matrix
    pub fn transform(v: Vector2, mat: Matrix) Vector2 -> Vector2.init(
        mat.m0*v.x + mat.m4*v.y + mat.m12,
        mat.m1*v.x + mat.m5*v.y + mat.m13,
    )
    // Calculate linear interpolation between two vectors
    pub fn lerp(v1, v2: Vector2, amount: f32) Vector2 -> Vector2.init(
        v1.x + amount*(v2.x - v1.x),
        v1.y + amount*(v2.y - v1.y),
    )
    // Calculate reflected vector to normal
    pub fn reflect(v, normal: Vector2) Vector2 {
        let dot_product = v.dot_product(normal); // Dot product

        return Vector2.init(
            v.x - (2.0*normal.x)*dot_product,
            v.y - (2.0*normal.y)*dot_product,
        );
    }
    // Get min value for each pair of components
    pub fn min(v1, v2: Vector2) Vector2 -> Vector2.init(std.min<f32>(v1.x, v2.x), std.min<f32>(v1.y, v2.y))
    // Get max value for each pair of components
    pub fn max(v1, v2: Vector2) Vector2 -> Vector2.init(std.max<f32>(v1.x, v2.x), std.max<f32>(v1.y, v2.y))
    // Rotate vector by angle
    pub fn rotate(v: Vector2, angle: f32) Vector2 {
        let cosres = std.cos<f32>(angle);
        let sinres = std.sin<f32>(angle);

        return Vector2.init(
            v.x*cosres - v.y*sinres,
            v.x*sinres + v.y*cosres,
        );
    }
    // Move Vector towards target
    pub fn move_towards(v, target: Vector2, maxDistance: f32) Vector2 {
        let dx = target.x - v.x;
        let dy = target.y - v.y;
        let value = (dx*dx) + (dy*dy);

        if ((value == 0) or ((maxDistance >= 0) and (value <= maxDistance*maxDistance))) return target;

        let dist = std.sqrt<f32>(value);

        return Vector2.init(
            v.x + dx/dist*maxDistance,
            v.y + dy/dist*maxDistance,
        );
    }
    // Invert the give nvector
    pub fn invert(v: Vector2) Vector2 -> Vector2.init(1.0/v.x, 1.0/v.y)
    // Clamp the components of the vector between
    // min and max values specified by the given vectors
    pub fn clamp(v, min, max: Vector2) Vector2 -> Vector2.init(
        std.max<f32>(max.x, std.max<f32>(min.x, v.x)),
        std.max<f32>(max.y, std.max<f32>(min.y, v.y)),
    )
    // Clamp the magnitude of the vector between two min and max values
    pub fn clamp_value(v: Vector2, min, max: f32) Vector2 ->
        if ((v.x*v.x) + (v.y*v.y) > 0.0) {
            let length = v.length();

            let scale = if (length < min) min/length
                else if (length > max) max/length
                else 1;

            Vector2.init(v.x*scale, v.y*scale)
        } else v

    // Check whether two given vectors are almost equal
    pub fn eq(p, q: Vector2) bool ->
        ((std.abs<f32>(p.x - q.x)) <= (EPSILON*std.max<f32>(1.0, std.max<f32>(std.abs<f32>(p.x), std.abs<f32>(q.x))))) and
            ((std.abs<f32>(p.y - q.y)) <= (EPSILON*std.max<f32>(1.0, std.max<f32>(std.abs<f32>(p.y), std.abs<f32>(q.y)))))
}

// Vector3, 3 components
pub struct Vector3 {
    x: f32,                // Vector x component
    y: f32,                // Vector y component
    z: f32,                // Vector z component

    pub fn init(x, y, z: f32) Vector3 -> Vector3 { x: x, y: y, z: z }
    // Vector with components value 0.0f
    pub fn zero() Vector3 -> Vector3.init(0, 0, 0)
    // Vector with components value 1.0f
    pub fn one() Vector3 -> Vector3.init(1, 1, 1)
    // Add two vectors
    pub fn add(v1, v2: Vector3) Vector3 -> Vector3.init(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z)
    // Add vector and float value
    pub fn add_value(v: Vector3, add: f32) Vector3 -> Vector3.init(v.x + add, v.y + add, v.z + add)
    // Subtract two vectors
    pub fn subtract(v1, v2: Vector3) Vector3 -> Vector3.init(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z)
    // Subtract vector by float value
    pub fn subtract_value(v: Vector3, sub: f32) Vector3 -> Vector3.init(v.x - sub, v.y - sub, v.z - sub)
    // Multiply vector by scalar
    pub fn scale(v: Vector3, scalar: f32) Vector3 -> Vector3.init(v.x*scalar, v.y*scalar, v.z*scalar)
    // Multiply vector by vector
    pub fn multiply(v1, v2: Vector3) Vector3 -> Vector3.init(v1.x*v2.x, v1.y*v2.y, v1.z*v2.z)
    // Calculate two vectors cross product
    pub fn cross_product(v1, v2: Vector3) Vector3 -> Vector3.init(
        v1.y*v2.z - v1.z*v2.y,
        v1.z*v2.x - v1.x*v2.z,
        v1.x*v2.y - v1.y*v2.x
    )
    // Calculate one vector perpendicular vector
    pub fn perpendicular(v: Vector3) Vector3 {
        let mut min_ = std.abs<f32>(v.x);
        let mut cardinalAxis = Vector3.init(1, 0, 0);

        if (std.abs<f32>(v.y) < min_) {
            min_ = std.abs<f32>(v.y);
            cardinalAxis = Vector3.init(0, 1, 0);
        }

        if (std.abs<f32>(v.z) < min_) cardinalAxis = Vector3.init(0, 0, 1);

        // Cross product between vectors
        return v.cross_product(cardinalAxis);
    }
    // Calculate vector length
    pub fn length(v: Vector3) f32 -> std.sqrt<f32>(v.length_sqr())
    // Calculate vector square length
    pub fn length_sqr(v: Vector3) f32 -> v.x*v.x + v.y*v.y + v.z*v.z
    // Calculate two vectors dot product
    pub fn dot_product(v1, v2: Vector3) f32 -> (v1.x*v2.x + v1.y*v2.y + v1.z*v2.z)
    // Calculate distance between two vectors
    pub fn distance(v1, v2: Vector3) f32 -> v2.subtract(v1).length()
    // Calculate square distance between two vectors
    pub fn distance_sqr(v1, v2: Vector3) f32 -> v2.subtract(v1).length_sqr()
    // Calculate angle between two vectors
    pub fn angle(v1, v2: Vector3) f32 -> std.atan2<f32>(v1.cross_product(v2).length(), v1.dot_product(v2))
    // Negate provided vector (invert direction)
    pub fn negate(v: Vector3) Vector3 -> Vector3.init(-v.x, -v.y, -v.z)
    // Divide vector by vector
    pub fn divide(v1, v2: Vector3) Vector3 -> Vector3.init(v1.x/v2.x, v1.y/v2.y, v1.z/v2.z)
    // Normalize provided vector
    pub fn normalize(v: Vector3) Vector3 -> if (v.length_sqr() > 0) v.scale(1.0 / v.length()) else v
    //Calculate the projection of the vector v1 on to v2
    pub fn project(v1, v2: Vector3) Vector3 {
        let v1dv2 = v1.dot_product(v2);
        let v2dv2 = v2.dot_product(v2);
        let mag = v1dv2/v2dv2;
        return v2.scale(mag);
    }
    //Calculate the rejection of the vector v1 on to v2
    pub fn reject(v1, v2: Vector3) Vector3 {
        return v1.subtract(v1.project(v2));
    }
    // Orthonormalize provided vectors
    // Makes vectors normalized and orthogonal to each other
    // Gram-Schmidt function implementation
    pub fn ortho_normalize(mut v1: &mut Vector3, mut v2: &mut Vector3) void {
        v1.* = v1.normalize();
        let vn1 = v1.cross_product(v2.*);
        v2.* = vn1.normalize();
    }

    // Transforms a Vector3 by a given Matrix
    pub fn transform(v: Vector3, mat: Matrix) Vector3 -> Vector3.init(
        mat.m0*v.x + mat.m4*v.y + mat.m8*v.z + mat.m12,
        mat.m1*v.x + mat.m5*v.y + mat.m9*v.z + mat.m13,
        mat.m2*v.x + mat.m6*v.y + mat.m10*v.z + mat.m14,
    )

    // Transform a vector by quaternion rotation
    pub fn rotate_by_quaternion(v: Vector3, q: Quaternion) Vector3 -> Vector3.init(
        v.x*(q.x*q.x + q.w*q.w - q.y*q.y - q.z*q.z) + v.y*(2.0*q.x*q.y - 2.0*q.w*q.z) + v.z*(2.0*q.x*q.z + 2.0*q.w*q.y),
        v.x*(2.0*q.w*q.z + 2.0*q.x*q.y) + v.y*(q.w*q.w - q.x*q.x + q.y*q.y - q.z*q.z) + v.z*(-2.0*q.w*q.x + 2.0*q.y*q.z),
        v.x*(-2.0*q.w*q.y + 2.0*q.x*q.z) + v.y*(2.0*q.w*q.x + 2.0*q.y*q.z)+ v.z*(q.w*q.w - q.x*q.x - q.y*q.y + q.z*q.z),
    )

    // Rotates a vector around an axis
    pub fn rotate_by_axis_angle(v: Vector3, axis: Vector3, angle: f32) Vector3 {
        // Using Euler-Rodrigues Formula
        // Ref.: https://en.wikipedia.org/w/index.php?title=Euler%E2%80%93Rodrigues_formula

        let mut result = v;
        let axis_ = axis.normalize();

        let mut mut_angle = angle / 2.0;
        let mut a = std.sin<f32>(mut_angle);
        let b = axis_.x*a;
        let c = axis_.y*a;
        let d = axis_.z*a;
        a = std.cos<f32>(mut_angle);
        let w = Vector3.init(b, c, d);

        let wv = w.cross_product(v);
        let wwv = w.cross_product(wv);

        result = result.add(wv.scale(2.0 * a));
        result = result.add(wwv.scale(2.0));

        return result;
    }

    // Move Vector towards target
    pub fn move_towards(v, target: Vector3, maxDistance: f32) Vector3 {
        let dx = target.x - v.x;
        let dy = target.y - v.y;
        let dz = target.z - v.z;
        let value = (dx*dx) + (dy*dy) + (dz*dz);

        if ((value == 0) or ((maxDistance >= 0) and (value <= maxDistance*maxDistance))) return target;

        let dist = std.sqrt<f32>(value);

        return Vector3.init(
            v.x + dx/dist*maxDistance,
            v.y + dy/dist*maxDistance,
            v.z + dz/dist*maxDistance,
        );
    }

    // Calculate linear interpolation between two vectors
    pub fn lerp(v1, v2: Vector3, amount: f32) Vector3 -> Vector3.init(
        v1.x + amount*(v2.x - v1.x),
        v1.y + amount*(v2.y - v1.y),
        v1.z + amount*(v2.z - v1.z),
    )

    // Calculate reflected vector to normal
    pub fn reflect(v, normal: Vector3) Vector3 {
        // I is the original vector
        // N is the normal of the incident plane
        // R = I - (2*N*(DotProduct[I, N]))

        let dotProduct = v.dot_product(normal);

        return Vector3.init(
            v.x - (2.0*normal.x)*dotProduct,
            v.y - (2.0*normal.y)*dotProduct,
            v.z - (2.0*normal.z)*dotProduct,
        );
    }

    // Get min value for each pair of components
    pub fn min(v1, v2: Vector3) Vector3 -> Vector3.init(std.min<f32>(v1.x, v2.x), std.min<f32>(v1.y, v2.y), std.min<f32>(v1.z, v2.z))

    // Get max value for each pair of components
    pub fn max(v1, v2: Vector3) Vector3 -> Vector3.init(std.max<f32>(v1.x, v2.x), std.max<f32>(v1.y, v2.y), std.max<f32>(v1.z, v2.z))

    // Compute barycenter coordinates (u, v, w) for point p with respect to triangle (a, b, c)
    // NOTE: Assumes P is on the plane of the triangle
    pub fn barycenter(p, a, b, c: Vector3) Vector3 {
        let v0 = b.subtract(a);
        let v1 = c.subtract(a);
        let v2 = p.subtract(a);
        let d00 = v0.dot_product(v0);
        let d01 = v0.dot_product(v1);
        let d11 = v1.dot_product(v1);
        let d20 = v2.dot_product(v0);
        let d21 = v2.dot_product(v1);

        let denom = d00*d11 - d01*d01;

        let v = (d11*d20 - d01*d21)/denom;
        let w = (d00*d21 - d01*d20)/denom;
        let u = 1.0 - (w + v);

        return Vector3.init(u, v, w);
    }

    // Projects a Vector3 from screen space into object space
    pub fn unproject(source: Vector3, projection, view: Matrix) Vector3 {
        let matViewProjInv = view.multiply(projection).invert();
        let quat = Vector4.init(source.x, source.y, source.z, 1.0);
        let qtransformed = quat.transform(matViewProjInv);

        // Normalized world points in vectors
        return Vector3.init(
            qtransformed.x/qtransformed.w,
            qtransformed.y/qtransformed.w,
            qtransformed.z/qtransformed.w,
        );
    }

    // Get Vector3 as float array
    pub fn to_float_v(v: Vector3) [3]f32 {
        return [_]f32{v.x, v.y, v.z};
    }

    // Invert the given vector
    pub fn invert(v: Vector3) Vector3 -> Vector3.init(1.0/v.x, 1.0/v.y, 1.0/v.z)

    // Clamp the components of the vector between
    // min and max values specified by the given vectors
    pub fn clamp(v, min, max: Vector3) Vector3 -> Vector3.init(
        std.max<f32>(max.x, std.max<f32>(min.x, v.x)),
        std.max<f32>(max.y, std.max<f32>(min.y, v.y)),
        std.max<f32>(max.z, std.max<f32>(min.z, v.z)),
    )

    // Clamp the magnitude of the vector between two values
    pub fn clamp_value(v: Vector3, min, max: f32) Vector3 {
        let mut length_ = v.length_sqr();
        if (length_ > 0.0) {
            length_ = std.sqrt<f32>(length_);
            let scale = if (length_ < min) min/length_
                else if (length_ > max) max/length_
                else 1.0;
            return v.scale(scale);
        }
        return v;
    }

    // Check whether two given vectors are almost equal
    pub fn eq(p, q: Vector3) bool ->
        ((std.abs<f32>(p.x - q.x)) <= (EPSILON*std.max<f32>(1.0, std.max<f32>(std.abs<f32>(p.x), std.abs<f32>(q.x))))) and
        ((std.abs<f32>(p.y - q.y)) <= (EPSILON*std.max<f32>(1.0, std.max<f32>(std.abs<f32>(p.y), std.abs<f32>(q.y))))) and
        ((std.abs<f32>(p.z - q.z)) <= (EPSILON*std.max<f32>(1.0, std.max<f32>(std.abs<f32>(p.z), std.abs<f32>(q.z)))))
}

// Vector4, 4 components
pub struct Vector4 {
    x: f32,                // Vector x component
    y: f32,                // Vector y component
    z: f32,                // Vector z component
    w: f32,                // Vector w component

    pub fn init(x, y, z, w: f32) Vector4 -> Vector4 { x: x, y: y, z: z, w: w }
    // Vector with components value 0.0f
    pub fn zero() Vector4 -> Vector4.init(0, 0, 0, 0)
    // Vector with components value 1.0f
    pub fn one() Vector4 -> Vector4.init(1, 1, 1, 1)
    // Add two vectors
    pub fn add(v1, v2: Vector4) Vector4 -> Vector4.init(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z, v1.w + v2.w)
    // Add vector and float value
    pub fn add_value(v: Vector4, add: f32) Vector4 -> Vector4.init(v.x + add, v.y + add, v.z + add, v.w + add)
    // Subtract two vectors
    pub fn subtract(v1, v2: Vector4) Vector4 -> Vector4.init(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z, v1.w - v2.w)
    // Subtract vector by float value
    pub fn subtract_value(v: Vector4, sub: f32) Vector4 -> Vector4.init(v.x - sub, v.y - sub, v.z - sub, v.w - sub)
    // Calculate vector length
    pub fn length(v: Vector4) f32 -> std.sqrt<f32>(v.length_sqr())
    // Calculate vector square length
    pub fn length_sqr(v: Vector4) f32 -> v.x*v.x + v.y*v.y + v.z*v.z + v.w*v.w
    // Calculate two vectors dot product
    pub fn dot_product(v1, v2: Vector4) f32 -> v1.x*v2.x + v1.y*v2.y + v1.z*v2.z + v1.w*v2.w
    // Calculate distance between two vectors
    pub fn distance(v1, v2: Vector4) f32 -> std.sqrt<f32>(v1.distance_sqr(v2))
    // Calculate square distance between two vectors
    pub fn distance_sqr(v1, v2: Vector4) f32 {
        let dx = v1.x - v2.x;
        let dy = v1.y - v2.y;
        let dz = v1.z - v2.z;
        let dw = v1.w - v2.w;
        return dx*dx + dy*dy + dz*dz + dw*dw;
    }
    // Scale vector (multiply by value)
    pub fn scale(v: Vector4, scale: f32) Vector4 -> Vector4.init(v.x*scale, v.y*scale, v.z*scale, v.w*scale)
    // Multiply vector by vector
    pub fn multiply(v1, v2: Vector4) Vector4 -> Vector4.init(v1.x*v2.x, v1.y*v2.y, v1.z*v2.z, v1.w*v2.w)
    // Negate vector
    pub fn negate(v: Vector4) Vector4 -> Vector4.init(-v.x, -v.y, -v.z, -v.w)
    // Divide vector by vector
    pub fn divide(v1, v2: Vector4) Vector4 -> Vector4.init(v1.x/v2.x, v1.y/v2.y, v1.z/v2.z, v1.w/v2.w)
    // Normalize provided vector
    pub fn normalize(v: Vector4) Vector4 -> if (v.length_sqr() > 0) v.scale(1.0 / v.length()) else v
    // Get min value for each pair of components
    pub fn min(v1, v2: Vector4) Vector4 -> Vector4.init(std.min<f32>(v1.x, v2.x), std.min<f32>(v1.y, v2.y), std.min<f32>(v1.z, v2.z), std.min<f32>(v1.w, v2.w))
    // Get max value for each pair of components
    pub fn max(v1, v2: Vector4) Vector4 -> Vector4.init(std.max<f32>(v1.x, v2.x), std.max<f32>(v1.y, v2.y), std.max<f32>(v1.z, v2.z), std.max<f32>(v1.w, v2.w))
    // Calculate linear interpolation between two vectors
    pub fn lerp(v1, v2: Vector4, amount: f32) Vector4 -> Vector4.init(
        v1.x + amount*(v2.x - v1.x),
        v1.y + amount*(v2.y - v1.y),
        v1.z + amount*(v2.z - v1.z),
        v1.w + amount*(v2.w - v1.w),
    )
    // Move Vector towards target
    pub fn move_towards(v, target: Vector4, maxDistance: f32) Vector4 {
        let dx = target.x - v.x;
        let dy = target.y - v.y;
        let dz = target.z - v.z;
        let dw = target.w - v.w;
        let value = (dx*dx) + (dy*dy) + (dz*dz) + (dw*dw);

        if ((value == 0) or ((maxDistance >= 0) and (value <= maxDistance*maxDistance))) return target;

        let dist = std.sqrt<f32>(value);

        return Vector4.init(
            v.x + dx/dist*maxDistance,
            v.y + dy/dist*maxDistance,
            v.z + dz/dist*maxDistance,
            v.w + dw/dist*maxDistance,
        );
    }
    // Invert the given vector
    pub fn invert(v: Vector4) Vector4 -> Vector4.init(1.0/v.x, 1.0/v.y, 1.0/v.z, 1.0/v.w)
    // Check whether two given vectors are almost equal
    pub fn eq(p, q: Vector4) bool ->
        ((std.abs<f32>(p.x - q.x)) <= (EPSILON*std.max<f32>(1.0, std.max<f32>(std.abs<f32>(p.x), std.abs<f32>(q.x))))) and
        ((std.abs<f32>(p.y - q.y)) <= (EPSILON*std.max<f32>(1.0, std.max<f32>(std.abs<f32>(p.y), std.abs<f32>(q.y))))) and
        ((std.abs<f32>(p.z - q.z)) <= (EPSILON*std.max<f32>(1.0, std.max<f32>(std.abs<f32>(p.z), std.abs<f32>(q.z))))) and
        ((std.abs<f32>(p.w - q.w)) <= (EPSILON*std.max<f32>(1.0, std.max<f32>(std.abs<f32>(p.w), std.abs<f32>(q.w)))))

    pub fn transform(v: Vector4, mat: Matrix) Vector4 -> Vector4.init(
        mat.m0*v.x + mat.m4*v.y + mat.m8*v.z + mat.m12*v.w,
        mat.m1*v.x + mat.m5*v.y + mat.m9*v.z + mat.m13*v.w,
        mat.m2*v.x + mat.m6*v.y + mat.m10*v.z + mat.m14*v.w,
        mat.m3*v.x + mat.m7*v.y + mat.m11*v.z + mat.m15*v.w,
    )
}

// Quaternion, 4 components (Vector4 alias)
pub struct Quaternion {
    x: f32, y: f32, z: f32, w: f32,

    pub fn zero() Quaternion -> Quaternion.init(0, 0, 0, 0)
    pub fn init(x: f32, y: f32, z: f32, w: f32) Quaternion -> Quaternion { x:x, y:y, z:z, w:w }
    pub fn add(q1: Quaternion, q2: Quaternion) Quaternion -> Quaternion.init(q1.x + q2.x, q1.y + q2.y, q1.z + q2.z, q1.w + q2.w)
    pub fn add_value(q: Quaternion, add: f32) Quaternion -> Quaternion.init(q.x + add, q.y + add, q.z + add, q.w + add)
    pub fn subtract(q1: Quaternion, q2: Quaternion) Quaternion -> Quaternion.init(q1.x - q2.x, q1.y - q2.y, q1.z - q2.z, q1.w - q2.w)
    pub fn subtract_value(q: Quaternion, sub: f32) Quaternion -> Quaternion.init(q.x - sub, q.y - sub, q.z - sub, q.w - sub)
    pub fn identity() Quaternion -> Quaternion.init(0.0, 0.0, 0.0, 1.0)
    pub fn length(q: Quaternion) f32 -> std.sqrt<f32>(q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w)

    pub fn normalize(q: Quaternion) Quaternion {
        let length_ = q.length();
        if (length_ == 0.0) return q;
        let ilength = 1.0 / length_;
        return Quaternion.init(q.x*ilength, q.y*ilength, q.z*ilength, q.w*ilength);
    }

    pub fn invert(q: Quaternion) Quaternion {
        let mut result = q;
        let lengthSq = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w;
        if (lengthSq != 0.0) {
            let invLength = 1.0 / lengthSq;
            result.x *= -invLength;
            result.y *= -invLength;
            result.z *= -invLength;
            result.w *= invLength;
        }
        return result;
    }

    pub fn multiply(q1: Quaternion, q2: Quaternion) Quaternion -> Quaternion.init(
        q1.x * q2.w + q1.w * q2.x + q1.y * q2.z - q1.z * q2.y,
        q1.y * q2.w + q1.w * q2.y + q1.z * q2.x - q1.x * q2.z,
        q1.z * q2.w + q1.w * q2.z + q1.x * q2.y - q1.y * q2.x,
        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z
    )

    pub fn scale(q: Quaternion, mul: f32) Quaternion -> Quaternion.init(q.x * mul, q.y * mul, q.z * mul, q.w * mul)

    pub fn divide(q1: Quaternion, q2: Quaternion) Quaternion -> Quaternion.init(q1.x / q2.x, q1.y / q2.y, q1.z / q2.z, q1.w / q2.w)

    pub fn lerp(q1: Quaternion, q2: Quaternion, amount: f32) Quaternion -> Quaternion.init(
        q1.x + amount * (q2.x - q1.x),
        q1.y + amount * (q2.y - q1.y),
        q1.z + amount * (q2.z - q1.z),
        q1.w + amount * (q2.w - q1.w)
    )

    pub fn nlerp(q1: Quaternion, q2: Quaternion, amount: f32) Quaternion -> q1.lerp(q2, amount).normalize()

    pub fn slerp(q1: Quaternion, mut q2: Quaternion, amount: f32) Quaternion {
        let mut cosHalfTheta = q1.x * q2.x + q1.y * q2.y + q1.z * q2.z + q1.w * q2.w;

        if (cosHalfTheta < 0) {
            q2.x = -q2.x; q2.y = -q2.y; q2.z = -q2.z; q2.w = -q2.w;
            cosHalfTheta = -cosHalfTheta;
        }

        if (std.abs<f32>(cosHalfTheta) >= 1.0) return q1;
        if (cosHalfTheta > 0.95) return q1.nlerp(q2, amount);

        let halfTheta = std.acos<f32>(cosHalfTheta);
        let sinHalfTheta = std.sqrt<f32>(1.0 - cosHalfTheta*cosHalfTheta);

        if (std.abs<f32>(sinHalfTheta) < EPSILON) {
            return Quaternion.init(
                (q1.x*0.5 + q2.x*0.5),
                (q1.y*0.5 + q2.y*0.5),
                (q1.z*0.5 + q2.z*0.5),
                (q1.w*0.5 + q2.w*0.5)
            );
        }

        let ratioA = std.sin<f32>((1.0 - amount) * halfTheta) / sinHalfTheta;
        let ratioB = std.sin<f32>(amount * halfTheta) / sinHalfTheta;

        return Quaternion.init(
            (q1.x * ratioA + q2.x * ratioB),
            (q1.y * ratioA + q2.y * ratioB),
            (q1.z * ratioA + q2.z * ratioB),
            (q1.w * ratioA + q2.w * ratioB)
        );
    }

    pub fn from_vector3_to_vector3(from: Vector3, to: Vector3) Quaternion {
        let cos2Theta = from.dot_product(to);
        let cross = from.cross_product(to);

        let result = Quaternion.init(cross.x, cross.y, cross.z, std.sqrt<f32>(cross.length_sqr() + cos2Theta*cos2Theta) + cos2Theta);
        return result.normalize();
    }

    pub fn from_matrix(mat: Matrix) Quaternion {
        let mut result = Quaternion.zero();
        let fourWSquaredMinus1 = mat.m0 + mat.m5 + mat.m10;
        let fourXSquaredMinus1 = mat.m0 - mat.m5 - mat.m10;
        let fourYSquaredMinus1 = mat.m5 - mat.m0 - mat.m10;
        let fourZSquaredMinus1 = mat.m10 - mat.m0 - mat.m5;

        let mut biggestIndex = 0;
        let mut fourBiggestSquaredMinus1 = fourWSquaredMinus1;
        if (fourXSquaredMinus1 > fourBiggestSquaredMinus1) {
            fourBiggestSquaredMinus1 = fourXSquaredMinus1;
            biggestIndex = 1;
        }

        if (fourYSquaredMinus1 > fourBiggestSquaredMinus1) {
            fourBiggestSquaredMinus1 = fourYSquaredMinus1;
            biggestIndex = 2;
        }

        if (fourZSquaredMinus1 > fourBiggestSquaredMinus1) {
            fourBiggestSquaredMinus1 = fourZSquaredMinus1;
            biggestIndex = 3;
        }

        let biggestVal = std.sqrt<f32>(fourBiggestSquaredMinus1 + 1.0) * 0.5;
        let mult = 0.25 / biggestVal;

        match (biggestIndex) {
            0 -> {
                result.w = biggestVal;
                result.x = (mat.m6 - mat.m9) * mult;
                result.y = (mat.m8 - mat.m2) * mult;
                result.z = (mat.m1 - mat.m4) * mult;
            },
            1 -> {
                result.x = biggestVal;
                result.w = (mat.m6 - mat.m9) * mult;
                result.y = (mat.m1 + mat.m4) * mult;
                result.z = (mat.m8 + mat.m2) * mult;
            },
            2 -> {
                result.y = biggestVal;
                result.w = (mat.m8 - mat.m2) * mult;
                result.x = (mat.m1 + mat.m4) * mult;
                result.z = (mat.m6 + mat.m9) * mult;
            },
            3 -> {
                result.z = biggestVal;
                result.w = (mat.m1 - mat.m4) * mult;
                result.x = (mat.m8 + mat.m2) * mult;
                result.y = (mat.m6 + mat.m9) * mult;
            },
        }
        return result;
    }

    pub fn to_matrix(q: Quaternion) Matrix {
        let a2 = q.x * q.x;
        let b2 = q.y * q.y;
        let c2 = q.z * q.z;
        let ac = q.x * q.z;
        let ab = q.x * q.y;
        let bc = q.y * q.z;
        let ad = q.w * q.x;
        let bd = q.w * q.y;
        let cd = q.w * q.z;

        return Matrix.init(
            1.0 - 2.0 * (b2 + c2), 2.0 * (ab + cd), 2.0 * (ac - bd), 0.0,
            2.0 * (ab - cd), 1.0 - 2.0 * (a2 + c2), 2.0 * (bc + ad), 0.0,
            2.0 * (ac + bd), 2.0 * (bc - ad), 1.0 - 2.0 * (a2 + b2), 0.0,
            0.0, 0.0, 0.0, 1.0
        );
    }

    pub fn from_axis_angle(mut axis: Vector3, mut angle: f32) Quaternion {
        if (axis.length_sqr() == 0.0) return Quaternion.identity();

        let mut result = Quaternion.identity();
        angle *= 0.5;
        axis = axis.normalize();
        let sinres = std.sin<f32>(angle);

        result.x = axis.x * sinres;
        result.y = axis.y * sinres;
        result.z = axis.z * sinres;
        result.w = std.cos<f32>(angle);

        return result.normalize();
    }

    pub fn to_axis_angle(mut q: Quaternion, outAxis: &mut Vector3, outAngle: &mut f32) void {
        if (std.abs<f32>(q.w) > 1.0) q = q.normalize();

        outAngle.* = 2.0 * std.acos<f32>(q.w);
        let den = std.sqrt<f32>(1.0 - q.w*q.w);

        if (den > EPSILON) {
            outAxis.x = q.x / den;
            outAxis.y = q.y / den;
            outAxis.z = q.z / den;
        } else {
            outAxis.x = 1.0;
        }
    }

    pub fn from_euler(pitch: f32, yaw: f32, roll: f32) Quaternion {
        let x0 = std.cos<f32>(pitch * 0.5);
        let x1 = std.sin<f32>(pitch * 0.5);
        let y0 = std.cos<f32>(yaw * 0.5);
        let y1 = std.sin<f32>(yaw * 0.5);
        let z0 = std.cos<f32>(roll * 0.5);
        let z1 = std.sin<f32>(roll * 0.5);

        return Quaternion.init(
            x1 * y0 * z0 - x0 * y1 * z1,
            x0 * y1 * z0 + x1 * y0 * z1,
            x0 * y0 * z1 - x1 * y1 * z0,
            x0 * y0 * z0 + x1 * y1 * z1
        );
    }

    pub fn to_euler(q: Quaternion) Vector3 {
        let x0 = 2.0 * (q.w * q.x + q.y * q.z);
        let x1 = 1.0 - 2.0 * (q.x * q.x + q.y * q.y);
        let x = std.atan2<f32>(x0, x1);

        let mut y0 = 2.0 * (q.w * q.y - q.z * q.x);
        y0 = if (y0 > 1.0) 1.0 else y0;
        y0 = if (y0 < -1.0) -1.0 else y0;
        let y = std.asin<f32>(y0);

        let z0 = 2.0 * (q.w * q.z + q.x * q.y);
        let z1 = 1.0 - 2.0 * (q.y * q.y + q.z * q.z);
        let z = std.atan2<f32>(z0, z1);

        return Vector3.init(x, y, z);
    }

    pub fn transform(q: Quaternion, mat: Matrix) Quaternion -> Quaternion.init(
        mat.m0 * q.x + mat.m4 * q.y + mat.m8 * q.z + mat.m12 * q.w,
        mat.m1 * q.x + mat.m5 * q.y + mat.m9 * q.z + mat.m13 * q.w,
        mat.m2 * q.x + mat.m6 * q.y + mat.m10 * q.z + mat.m14 * q.w,
        mat.m3 * q.x + mat.m7 * q.y + mat.m11 * q.z + mat.m15 * q.w
    )

    pub fn eq(p: Quaternion, q: Quaternion) bool ->
        (((std.abs<f32>(p.x - q.x)) <= (EPSILON*std.max<f32>(1.0, std.max<f32>(std.abs<f32>(p.x), std.abs<f32>(q.x))))) and
        ((std.abs<f32>(p.y - q.y)) <= (EPSILON*std.max<f32>(1.0, std.max<f32>(std.abs<f32>(p.y), std.abs<f32>(q.y))))) and
        ((std.abs<f32>(p.z - q.z)) <= (EPSILON*std.max<f32>(1.0, std.max<f32>(std.abs<f32>(p.z), std.abs<f32>(q.z))))) and
        ((std.abs<f32>(p.w - q.w)) <= (EPSILON*std.max<f32>(1.0, std.max<f32>(std.abs<f32>(p.w), std.abs<f32>(q.w)))))) or
        (((std.abs<f32>(p.x + q.x)) <= (EPSILON*std.max<f32>(1.0, std.max<f32>(std.abs<f32>(p.x), std.abs<f32>(q.x))))) and
        ((std.abs<f32>(p.y + q.y)) <= (EPSILON*std.max<f32>(1.0, std.max<f32>(std.abs<f32>(p.y), std.abs<f32>(q.y))))) and
        ((std.abs<f32>(p.z + q.z)) <= (EPSILON*std.max<f32>(1.0, std.max<f32>(std.abs<f32>(p.z), std.abs<f32>(q.z))))) and
        ((std.abs<f32>(p.w + q.w)) <= (EPSILON*std.max<f32>(1.0, std.max<f32>(std.abs<f32>(p.w), std.abs<f32>(q.w))))))
}

// Matrix, 4x4 components, column major, OpenGL style, right-handed
pub struct Matrix {
    m0: f32, m4: f32, m8: f32, m12: f32,  // Matrix first row (4 components)
    m1: f32, m5: f32, m9: f32, m13: f32,  // Matrix second row (4 components)
    m2: f32, m6: f32, m10: f32, m14: f32, // Matrix third row (4 components)
    m3: f32, m7: f32, m11: f32, m15: f32, // Matrix fourth row (4 components)

    pub fn init(m0: f32, m4: f32, m8: f32, m12: f32, m1: f32, m5: f32, m9: f32, m13: f32, m2: f32, m6: f32, m10: f32, m14: f32, m3: f32, m7: f32, m11: f32, m15: f32) Matrix {
        return Matrix {
            m0: m0, m4: m4, m8: m8, m12: m12,
            m1: m1, m5: m5, m9: m9, m13: m13,
            m2: m2, m6: m6, m10: m10, m14: m14,
            m3: m3, m7: m7, m11: m11, m15: m15,
        };
    }

    pub fn determinant(mat: Matrix) f32 {
        return (mat.m0 * ((mat.m5 * (mat.m10 * mat.m15 - mat.m11 * mat.m14) - mat.m9 * (mat.m6 * mat.m15 - mat.m7 * mat.m14) + mat.m13 * (mat.m6 * mat.m11 - mat.m7 * mat.m10))) -
                mat.m4 * ((mat.m1 * (mat.m10 * mat.m15 - mat.m11 * mat.m14) - mat.m9 * (mat.m2 * mat.m15 - mat.m3 * mat.m14) + mat.m13 * (mat.m2 * mat.m11 - mat.m3 * mat.m10))) +
                mat.m8 * ((mat.m1 * (mat.m6 * mat.m15 - mat.m7 * mat.m14) - mat.m5 * (mat.m2 * mat.m15 - mat.m3 * mat.m14) + mat.m13 * (mat.m2 * mat.m7 - mat.m3 * mat.m6))) -
                mat.m12 * ((mat.m1 * (mat.m6 * mat.m11 - mat.m7 * mat.m10) - mat.m5 * (mat.m2 * mat.m11 - mat.m3 * mat.m10) + mat.m9 * (mat.m2 * mat.m7 - mat.m3 * mat.m6))));
    }

    pub fn trace(mat: Matrix) f32 -> mat.m0 + mat.m5 + mat.m10 + mat.m15

    pub fn transpose(mat: Matrix) Matrix {
        return Matrix.init(
            mat.m0, mat.m1, mat.m2, mat.m3,
            mat.m4, mat.m5, mat.m6, mat.m7,
            mat.m8, mat.m9, mat.m10, mat.m11,
            mat.m12, mat.m13, mat.m14, mat.m15
        );
    }

    pub fn invert(mat: Matrix) Matrix {
        let a00 = mat.m0; let a01 = mat.m1; let a02 = mat.m2; let a03 = mat.m3;
        let a10 = mat.m4; let a11 = mat.m5; let a12 = mat.m6; let a13 = mat.m7;
        let a20 = mat.m8; let a21 = mat.m9; let a22 = mat.m10; let a23 = mat.m11;
        let a30 = mat.m12; let a31 = mat.m13; let a32 = mat.m14; let a33 = mat.m15;

        let b00 = a00*a11 - a01*a10;
        let b01 = a00*a12 - a02*a10;
        let b02 = a00*a13 - a03*a10;
        let b03 = a01*a12 - a02*a11;
        let b04 = a01*a13 - a03*a11;
        let b05 = a02*a13 - a03*a12;
        let b06 = a20*a31 - a21*a30;
        let b07 = a20*a32 - a22*a30;
        let b08 = a20*a33 - a23*a30;
        let b09 = a21*a32 - a22*a31;
        let b10 = a21*a33 - a23*a31;
        let b11 = a22*a33 - a23*a32;

        let invDet = 1.0/(b00*b11 - b01*b10 + b02*b09 + b03*b08 - b04*b07 + b05*b06);

        return Matrix.init(
            (a11*b11 - a12*b10 + a13*b09)*invDet,
            (-a01*b11 + a02*b10 - a03*b09)*invDet,
            (a31*b05 - a32*b04 + a33*b03)*invDet,
            (-a21*b05 + a22*b04 - a23*b03)*invDet,
            (-a10*b11 + a12*b08 - a13*b07)*invDet,
            (a00*b11 - a02*b08 + a03*b07)*invDet,
            (-a30*b05 + a32*b02 - a33*b01)*invDet,
            (a20*b05 - a22*b02 + a23*b01)*invDet,
            (a10*b10 - a11*b08 + a13*b06)*invDet,
            (-a00*b10 + a01*b08 - a03*b06)*invDet,
            (a30*b04 - a31*b02 + a33*b00)*invDet,
            (-a20*b04 + a21*b02 - a23*b00)*invDet,
            (-a10*b09 + a11*b07 - a12*b06)*invDet,
            (a00*b09 - a01*b07 + a02*b06)*invDet,
            (-a30*b03 + a31*b01 - a32*b00)*invDet,
            (a20*b03 - a21*b01 + a22*b00)*invDet
        );
    }

    pub fn identity() Matrix {
        return Matrix.init(
            1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            0.0, 0.0, 0.0, 1.0
        );
    }

    pub fn add(left: Matrix, right: Matrix) Matrix {
        return Matrix.init(
            left.m0 + right.m0, left.m1 + right.m1, left.m2 + right.m2, left.m3 + right.m3,
            left.m4 + right.m4, left.m5 + right.m5, left.m6 + right.m6, left.m7 + right.m7,
            left.m8 + right.m8, left.m9 + right.m9, left.m10 + right.m10, left.m11 + right.m11,
            left.m12 + right.m12, left.m13 + right.m13, left.m14 + right.m14, left.m15 + right.m15
        );
    }

    pub fn subtract(left: Matrix, right: Matrix) Matrix {
        return Matrix.init(
            left.m0 - right.m0, left.m1 - right.m1, left.m2 - right.m2, left.m3 - right.m3,
            left.m4 - right.m4, left.m5 - right.m5, left.m6 - right.m6, left.m7 - right.m7,
            left.m8 - right.m8, left.m9 - right.m9, left.m10 - right.m10, left.m11 - right.m11,
            left.m12 - right.m12, left.m13 - right.m13, left.m14 - right.m14, left.m15 - right.m15
        );
    }

    pub fn multiply(left: Matrix, right: Matrix) Matrix {
        return Matrix.init(
            left.m0*right.m0 + left.m1*right.m4 + left.m2*right.m8 + left.m3*right.m12,
            left.m0*right.m1 + left.m1*right.m5 + left.m2*right.m9 + left.m3*right.m13,
            left.m0*right.m2 + left.m1*right.m6 + left.m2*right.m10 + left.m3*right.m14,
            left.m0*right.m3 + left.m1*right.m7 + left.m2*right.m11 + left.m3*right.m15,
            left.m4*right.m0 + left.m5*right.m4 + left.m6*right.m8 + left.m7*right.m12,
            left.m4*right.m1 + left.m5*right.m5 + left.m6*right.m9 + left.m7*right.m13,
            left.m4*right.m2 + left.m5*right.m6 + left.m6*right.m10 + left.m7*right.m14,
            left.m4*right.m3 + left.m5*right.m7 + left.m6*right.m11 + left.m7*right.m15,
            left.m8*right.m0 + left.m9*right.m4 + left.m10*right.m8 + left.m11*right.m12,
            left.m8*right.m1 + left.m9*right.m5 + left.m10*right.m9 + left.m11*right.m13,
            left.m8*right.m2 + left.m9*right.m6 + left.m10*right.m10 + left.m11*right.m14,
            left.m8*right.m3 + left.m9*right.m7 + left.m10*right.m11 + left.m11*right.m15,
            left.m12*right.m0 + left.m13*right.m4 + left.m14*right.m8 + left.m15*right.m12,
            left.m12*right.m1 + left.m13*right.m5 + left.m14*right.m9 + left.m15*right.m13,
            left.m12*right.m2 + left.m13*right.m6 + left.m14*right.m10 + left.m15*right.m14,
            left.m12*right.m3 + left.m13*right.m7 + left.m14*right.m11 + left.m15*right.m15
        );
    }

    pub fn translate(x: f32, y: f32, z: f32) Matrix {
        return Matrix.init(
            1.0, 0.0, 0.0, x,
            0.0, 1.0, 0.0, y,
            0.0, 0.0, 1.0, z,
            0.0, 0.0, 0.0, 1.0
        );
    }

    // NOTE: Angle should be provided in radians
    pub fn rotate(mut axis: Vector3, angle: f32) Matrix {
        axis = axis.normalize();

        let sinres = std.sin<f32>(angle);
        let cosres = std.cos<f32>(angle);
        let t = 1.0 - cosres;

        let x = axis.x;
        let y = axis.y;
        let z = axis.z;

        return Matrix.init(
            x * x * t + cosres, y * x * t + z * sinres, z * x * t - y * sinres, 0.0,
            x * y * t - z * sinres, y * y * t + cosres, z * y * t + x * sinres, 0.0,
            x * z * t + y * sinres, y * z * t - x * sinres, z * z * t + cosres, 0.0,
            0.0, 0.0, 0.0, 1.0
        );
    }

    // NOTE: Angle must be provided in radians
    pub fn rotate_x(angle: f32) Matrix {
        let cosres = std.cos<f32>(angle);
        let sinres = std.sin<f32>(angle);
        return Matrix.init(
            1.0, 0.0, 0.0, 0.0,
            0.0, cosres, sinres, 0.0,
            0.0, -sinres, cosres, 0.0,
            0.0, 0.0, 0.0, 1.0
        );
    }

    // NOTE: Angle must be provided in radians
    pub fn rotate_y(angle: f32) Matrix {
        let cosres = std.cos<f32>(angle);
        let sinres = std.sin<f32>(angle);
        return Matrix.init(
            cosres, 0.0, -sinres, 0.0,
            0.0, 1.0, 0.0, 0.0,
            sinres, 0.0, cosres, 0.0,
            0.0, 0.0, 0.0, 1.0
        );
    }

    // NOTE: Angle must be provided in radians
    pub fn rotate_z(angle: f32) Matrix {
        let cosres = std.cos<f32>(angle);
        let sinres = std.sin<f32>(angle);
        return Matrix.init(
            cosres, sinres, 0.0, 0.0,
            -sinres, cosres, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            0.0, 0.0, 0.0, 1.0
        );
    }

    // NOTE: Angle must be provided in radians
    pub fn rotate_xyz(angle: Vector3) Matrix {
        let cosz = std.cos<f32>(-angle.z);
        let sinz = std.sin<f32>(-angle.z);
        let cosy = std.cos<f32>(-angle.y);
        let siny = std.sin<f32>(-angle.y);
        let cosx = std.cos<f32>(-angle.x);
        let sinx = std.sin<f32>(-angle.x);

        return Matrix.init(
            cosz * cosy,
            (cosz * siny * sinx) - (sinz * cosx),
            (cosz * siny * cosx) + (sinz * sinx),
            0.0,
            sinz * cosy,
            (sinz * siny * sinx) + (cosz * cosx),
            (sinz * siny * cosx) - (cosz * sinx),
            0.0,
            -siny,
            cosy * sinx,
            cosy * cosx,
            0.0,
            0.0, 0.0, 0.0, 1.0
        );
    }

    // NOTE: Angle must be provided in radians
    pub fn rotate_zyx(angle: Vector3) Matrix {
        let cz = std.cos<f32>(angle.z);
        let sz = std.sin<f32>(angle.z);
        let cy = std.cos<f32>(angle.y);
        let sy = std.sin<f32>(angle.y);
        let cx = std.cos<f32>(angle.x);
        let sx = std.sin<f32>(angle.x);

        return Matrix.init(
            cz * cy,
            cy * sz,
            -sy,
            0.0,
            cz * sy * sx - cx * sz,
            cz * cx + sz * sy * sx,
            cy * sx,
            0.0,
            sz * sx + cz * cx * sy,
            cx * sz * sy - cz * sx,
            cy * cx,
            0.0,
            0.0, 0.0, 0.0, 1.0
        );
    }

    pub fn scale(x: f32, y: f32, z: f32) Matrix {
        return Matrix.init(
            x,   0.0, 0.0, 0.0,
            0.0, y,   0.0, 0.0,
            0.0, 0.0, z,   0.0,
            0.0, 0.0, 0.0, 1.0
        );
    }

    pub fn frustum(left: f64, right: f64, bottom: f64, top: f64, near: f64, far: f64) Matrix {
        let rl = cast<f32>(right - left);
        let tb = cast<f32>(top - bottom);
        let fn_ = cast<f32>(far - near);
        let near2 = cast<f32>(near * 2.0);

        return Matrix.init(
            near2 / rl, 0.0, cast<f32>((right + left) / rl), 0.0,
            0.0, near2 / tb, cast<f32>((top + bottom) / tb), 0.0,
            0.0, 0.0, -cast<f32>((far + near) / fn_), -cast<f32>((far * near * 2.0) / fn_),
            0.0, 0.0, -1.0, 0.0
        );
    }

    // NOTE: Fovy angle must be provided in radians
    pub fn perspective(fovY: f64, aspect: f64, near: f64, far: f64) Matrix {
        let top = near * std.tan<f32>(fovY * 0.5);
        let bottom = -top;
        let right = top * aspect;
        let left = -right;
        return Matrix.frustum(left, right, bottom, top, near, far);
    }

    pub fn ortho(left: f64, right: f64, bottom: f64, top: f64, near: f64, far: f64) Matrix {
        let rl = cast<f32>(right - left);
        let tb = cast<f32>(top - bottom);
        let fn_ = cast<f32>(far - near);

        return Matrix.init(
            2.0 / rl, 0.0, 0.0, -cast<f32>((left + right) / rl),
            0.0, 2.0 / tb, 0.0, -cast<f32>((top + bottom) / tb),
            0.0, 0.0, -2.0 / fn_, -cast<f32>((far + near) / fn_),
            0.0, 0.0, 0.0, 1.0
        );
    }

    pub fn look_at(eye: Vector3, target: Vector3, up: Vector3) Matrix {
        let vz = eye.subtract(target).normalize();
        let vx = up.cross_product(vz).normalize();
        let vy = vz.cross_product(vx);

        return Matrix.init(
            vx.x, vx.y, vx.z, -vx.dot_product(eye),
            vy.x, vy.y, vy.z, -vy.dot_product(eye),
            vz.x, vz.y, vz.z, -vz.dot_product(eye),
            0.0, 0.0, 0.0, 1.0
        );
    }

    pub fn to_float_v(mat: Matrix) [16]f32 {
        return [_]f32{
            mat.m0, mat.m1, mat.m2, mat.m3,
            mat.m4, mat.m5, mat.m6, mat.m7,
            mat.m8, mat.m9, mat.m10, mat.m11,
            mat.m12, mat.m13, mat.m14, mat.m15,
        };
    }

    // Compose a transformation matrix from rotational, translational and scaling components
    // TODO: This function is not following raymath conventions defined in header: NOT self-contained
    pub fn compose(translation: Vector3, rotation: Quaternion, scale: Vector3) Matrix {
        // Scale vectors
        let right = Vector3.init(scale.x, 0, 0).rotate_by_quaternion(rotation);
        let up = Vector3.init(0, scale.y, 0).rotate_by_quaternion(rotation);
        let forward = Vector3.init(0, 0, scale.z).rotate_by_quaternion(rotation);

        // Set result matrix output
        return Matrix.init(
            right.x, up.x, forward.x, translation.x,
            right.y, up.y, forward.y, translation.y,
            right.z, up.z, forward.z, translation.z,
            0.0, 0.0, 0.0, 1.0,
        );
    }

    // Decompose a transformation matrix into its rotational, translational and scaling components and remove shear
    // TODO: This function is not following raymath conventions defined in header: NOT self-contained
    pub fn decompose(mat: Matrix, translation: &mut Vector3, rotation: &mut Quaternion, scale: &mut Vector3) void {
        let eps: f32 = 1e-9;

        // Extract Translation
        translation.x = mat.m12;
        translation.y = mat.m13;
        translation.z = mat.m14;

        // Matrix Columns - Rotation will be extracted into here.
        let mut matColumns = [_]Vector3{
            Vector3.init(mat.m0, mat.m4, mat.m8),
            Vector3.init(mat.m1, mat.m5, mat.m9),
            Vector3.init(mat.m2, mat.m6, mat.m10)
        };

        // Shear Parameters XY, XZ, and YZ (extract and ignored)
        let mut shear = [_]f32{ 0, 0, 0 };

        // Normalized Scale Parameters
        let mut scl = Vector3.zero();

        // Max-Normalizing helps numerical stability
        let mut stabilizer = eps;
        for (0..3) |i| {
            stabilizer = std.max<f32>(stabilizer, std.abs<f32>(matColumns[i].x));
            stabilizer = std.max<f32>(stabilizer, std.abs<f32>(matColumns[i].y));
            stabilizer = std.max<f32>(stabilizer, std.abs<f32>(matColumns[i].z));
        }
        matColumns[0] = matColumns[0].scale(1.0 / stabilizer);
        matColumns[1] = matColumns[1].scale(1.0 / stabilizer);
        matColumns[2] = matColumns[2].scale(1.0 / stabilizer);

        // X Scale
        scl.x = matColumns[0].length();
        if (scl.x > eps) matColumns[0] = matColumns[0].scale(1.0 / scl.x);

        // Compute XY shear and make col2 orthogonal
        shear[0] = matColumns[0].dot_product(matColumns[1]);
        matColumns[1] = matColumns[1].subtract(matColumns[0].scale(shear[0]));

        // Y Scale
        scl.y = matColumns[1].length();
        if (scl.y > eps) {
            matColumns[1] = matColumns[1].scale(1.0 / scl.y);
            shear[0] /= scl.y; // Correct XY shear
        }

        // Compute XZ and YZ shears and make col3 orthogonal
        shear[1] = matColumns[0].dot_product(matColumns[2]);
        matColumns[2] = matColumns[2].subtract(matColumns[0].scale(shear[1]));
        shear[2] = matColumns[1].dot_product(matColumns[2]);
        matColumns[2] = matColumns[2].subtract(matColumns[1].scale(shear[2]));

        // Z Scale
        scl.z = matColumns[2].length();
        if (scl.z > eps) {
            matColumns[2] = matColumns[2].scale(1.0 / scl.z);
            shear[1] /= scl.z; // Correct XZ shear
            shear[2] /= scl.z; // Correct YZ shear
        }

        // matColumns are now orthonormal in O(3). Now ensure its in SO(3) by enforcing det = 1.
        if (matColumns[0].dot_product(matColumns[1].cross_product(matColumns[2])) < 0) {
            scl = scl.negate();
            matColumns[0] = matColumns[0].negate();
            matColumns[1] = matColumns[1].negate();
            matColumns[2] = matColumns[2].negate();
        }

        // Set Scale
        scale.* = scl.scale(stabilizer);

        // Extract Rotation
        let rotationMatrix = Matrix.init(
            matColumns[0].x, matColumns[0].y, matColumns[0].z, 0,
            matColumns[1].x, matColumns[1].y, matColumns[1].z, 0,
            matColumns[2].x, matColumns[2].y, matColumns[2].z, 0,
            0, 0, 0, 1
        );
        rotation.* = Quaternion.from_matrix(rotationMatrix);
    }

}

// Color, 4 components, R8G8B8A8 (32bit)
pub struct Color {
    r: u8,        // Color red value
    g: u8,        // Color green value
    b: u8,        // Color blue value
    a: u8,        // Color alpha value

    pub fn init(r, g, b, a: u8) Color -> Color { r: r, g: g, b: b, a: a }
}

// Rectangle, 4 components
pub struct Rectangle {
    x: f32,                // Rectangle top-left corner position x
    y: f32,                // Rectangle top-left corner position y
    width: f32,            // Rectangle width
    height: f32,           // Rectangle height
}

// Image, pixel data stored in CPU memory (RAM)
pub struct Image {
    data: &mut void,             // Image raw data
    width: i32,              // Image base width
    height: i32,             // Image base height
    mipmaps: i32,            // Mipmap levels, 1 by default
    format: i32,             // Data format (PixelFormat type)
}

// Texture, tex data stored in GPU memory (VRAM)
pub struct Texture {
    id: u32,       // OpenGL texture id
    width: i32,              // Texture base width
    height: i32,             // Texture base height
    mipmaps: i32,            // Mipmap levels, 1 by default
    format: i32,             // Data format (PixelFormat type)
}

const Texture2D = Texture;
const TextureCubemap = Texture;

// RenderTexture, fbo for texture rendering
pub struct RenderTexture {
    id: u32,        // OpenGL framebuffer object id
    texture: Texture,        // Color buffer attachment texture
    depth: Texture,          // Depth buffer attachment texture
}

const RenderTexture2D = RenderTexture;

// NPatchInfo, n-patch layout info
pub struct NPatchInfo {
    source: Rectangle,       // Texture source rectangle
    left: i32,               // Left border offset
    top: i32,                // Top border offset
    right: i32,              // Right border offset
    bottom: i32,             // Bottom border offset
    layout: i32,             // Layout of the n-patch: 3x3, 1x3 or 3x1
}

// GlyphInfo, font characters glyphs info
pub struct GlyphInfo {
    value: i32,              // Character value (Unicode)
    offsetX: i32,            // Character offset X when drawing
    offsetY: i32,            // Character offset Y when drawing
    advanceX: i32,           // Character advance position X
    image: Image,            // Character image data
}

// Font, font texture and GlyphInfo array data
pub struct Font {
    baseSize: i32,           // Base size (default chars height)
    glyphCount: i32,         // Number of glyph characters
    glyphPadding: i32,       // Padding around the glyph characters
    texture: Texture2D,      // Texture atlas containing the glyphs
    recs: &mut Rectangle,        // Rectangles in texture for the glyphs
    glyphs: &mut GlyphInfo,      // Glyphs info data
}

// Camera, defines position/orientation in 3d space
pub struct Camera3D {
    position: Vector3,       // Camera position
    target: Vector3,         // Camera target it looks-at
    up: Vector3,             // Camera up vector (rotation over its axis)
    fovy: f32,             // Camera field-of-view aperture in Y (degrees) in perspective, used as near plane height in world units in orthographic
    projection: i32,         // Camera projection: CAMERA_PERSPECTIVE or CAMERA_ORTHOGRAPHIC
}

const Camera = Camera3D;

// Camera2D, defines position/orientation in 2d space
pub struct Camera2D {
    offset: Vector2,         // Camera offset (screen space offset from window origin)
    target: Vector2,         // Camera target (world space target point that is mapped to screen space offset)
    rotation: f32,         // Camera rotation in degrees (pivots around target)
    zoom: f32,             // Camera zoom (scaling around target), must not be set to 0, set to 1.0f for no scale
}

// Mesh, vertex data and vao/vbo
pub struct Mesh {
    vertexCount: i32,        // Number of vertices stored in arrays
    triangleCount: i32,      // Number of triangles stored (indexed or not)

    // Vertex attributes data
    vertices: &mut f32,        // Vertex position (XYZ - 3 components per vertex) (shader-location = 0)
    texcoords: &mut f32,       // Vertex texture coordinates (UV - 2 components per vertex) (shader-location = 1)
    texcoords2: &mut f32,      // Vertex texture second coordinates (UV - 2 components per vertex) (shader-location = 5)
    normals: &mut f32,         // Vertex normals (XYZ - 3 components per vertex) (shader-location = 2)
    tangents: &mut f32,        // Vertex tangents (XYZW - 4 components per vertex) (shader-location = 4)
    colors: &mut u8,      // Vertex colors (RGBA - 4 components per vertex) (shader-location = 3)
    indices: &mut u16,    // Vertex indices (in case vertex data comes indexed)

    // Animation vertex data
    animVertices: &mut f32,    // Animated vertex positions (after bones transformations)
    animNormals: &mut f32,     // Animated normals (after bones transformations)
    boneIds: &mut u8, // Vertex bone ids, max 255 bone ids up to 4 bones influence by vertex (skinning) (shader-location = 6)
    boneWeights: &mut f32,     // Vertex bone weight up to 4 bones influence by vertex (skinning) (shader-location = 7)

    // OpenGL identifiers
    vaoId: u32,     // OpenGL Vertex Array Object id
    vboId: &mut u32,    // OpenGL Vertex Buffer Objects id (default vertex data)
}

// Shader
pub struct Shader {
    id: u32,        // Shader program id
    locs: &mut i32,   // Shader locations array (RL_MAX_SHADER_LOCATIONS)
}

// MaterialMap
pub struct MaterialMap {
    texture: Texture2D,      // Material map texture
    color: Color,            // Material map color
    value: f32,            // Material map value
}

// Material, includes shader and maps
pub struct Material {
    shader: Shader,          // Material shader
    maps: &mut MaterialMap,      // Material maps array (MAX_MATERIAL_MAPS)
    params: [4]f32,        // Material generic parameters (if required)
}

// Transform, vertex transformation data
pub struct Transform {
    translation: Vector3,    // Translation
    rotation: Quaternion,    // Rotation
    scale: Vector3,          // Scale
}

// Bone, skeletal animation bone
pub struct BoneInfo {
    name: [32]c_char,          // Bone name
    parent: i32,             // Bone parent
}

// Model, meshes, materials and animation data
pub struct Model {
    transform: Matrix,       // Local transform matrix

    meshCount: i32,          // Number of meshes
    materialCount: i32,      // Number of materials
    meshes: &mut Mesh,           // Meshes array
    materials: &mut Material,    // Materials array
    meshMaterial: &mut i32,      // Mesh material number

    // Animation data
    boneCount: i32,          // Number of bones
    bones: &mut BoneInfo,        // Bones information (skeleton)
    bindPose: &mut Transform,    // Bones base transformation (pose)
}

// ModelAnimation
pub struct ModelAnimation {
    boneCount: i32,          // Number of bones
    frameCount: i32,         // Number of animation frames
    bones: &BoneInfo,        // Bones information (skeleton)
    framePoses: &mut &mut Transform, // Poses array by frame
    name: [32]c_char,          // Animation name
}

// Ray, ray for raycasting
pub struct Ray {
    position: Vector3,       // Ray position (origin)
    direction: Vector3,      // Ray direction (normalized)
}

// RayCollision, ray hit information
pub struct RayCollision {
    hit: bool,               // Did the ray hit something?
    distance: f32,         // Distance to the nearest hit
    point: Vector3,          // Point of the nearest hit
    normal: Vector3,         // Surface normal of hit
}

// BoundingBox
pub struct BoundingBox {
    min: Vector3,            // Minimum vertex box-corner
    max: Vector3,            // Maximum vertex box-corner
}

// Wave, audio wave data
pub struct Wave {
    frameCount: u32,    // Total number of frames (considering channels)
    sampleRate: u32,    // Frequency (samples per second)
    sampleSize: u32,    // Bit depth (bits per sample): 8, 16, 32 (24 not supported)
    channels: u32,      // Number of channels (1-mono, 2-stereo, ...)
    data: &mut void,                 // Buffer data pointer
}

pub bind struct rAudioBuffer;
pub bind struct rAudioProcessor;

pub struct AudioStream {
    buffer: &mut rAudioBuffer,       // Pointer to internal data used by the audio system
    processor: &mut rAudioProcessor, // Pointer to internal data processor, useful for audio effects

    sampleRate: u32,    // Frequency (samples per second)
    sampleSize: u32,    // Bit depth (bits per sample): 8, 16, 32 (24 not supported)
    channels: u32,      // Number of channels (1-mono, 2-stereo, ...)
}

// Sound
pub struct Sound {
    stream: AudioStream,         // Audio stream
    frameCount: u32,    // Total number of frames (considering channels)
}

// Music, audio stream, anything longer than ~10 seconds should be streamed
pub struct Music {
    stream: AudioStream,         // Audio stream
    frameCount: u32,    // Total number of frames (considering channels)
    looping: bool,               // Music looping enable

    ctxType: i32,                // Type of music context (audio filetype)
    ctxData: &mut void,              // Audio context data, depends on type
}

// VrDeviceInfo, Head-Mounted-Display device parameters
pub struct VrDeviceInfo {
    hResolution: i32,                // Horizontal resolution in pixels
    vResolution: i32,                // Vertical resolution in pixels
    hScreenSize: f32,              // Horizontal size in meters
    vScreenSize: f32,              // Vertical size in meters
    eyeToScreenDistance: f32,      // Distance between eye and display in meters
    lensSeparationDistance: f32,   // Lens separation distance in meters
    interpupillaryDistance: f32,   // IPD (distance between pupils) in meters
    lensDistortionValues: [4]f32,  // Lens distortion constant parameters
    chromaAbCorrection: [4]f32,    // Chromatic aberration correction parameters
}

// VrStereoConfig, VR stereo rendering configuration for simulator
pub struct VrStereoConfig {
    projection: [2]Matrix,           // VR projection matrices (per eye)
    viewOffset: [2]Matrix,           // VR projection matrices (per eye)
    leftLensCenter: [2]f32,        // VR left lens center
    rightLensCenter: [2]f32,       // VR right lens center
    leftScreenCenter: [2]f32,      // VR left screen center
    rightScreenCenter: [2]f32,     // VR right screen center
    scale: [2]f32,                 // VR distortion scale
    scaleIn: [2]f32,               // VR distortion scale in
}

// File path list
pub struct FilePathList {
    count: u32,             // Filepaths entries count
    paths: &mut &mut c_char,                   // Filepaths entries
}

// Automation event
pub struct AutomationEvent {
    frame: u32,             // Event frame
    type: u32,              // Event type (AutomationEventType)
    params: [4]i32,                  // Event parameters (if required)
}

// Automation event list
pub struct AutomationEventList {
    capacity: u32,          // Events max entries (MAX_AUTOMATION_EVENTS)
    count: u32,             // Events entries count
    events: &mut AutomationEvent,        // Events entries
}

pub enum ConfigFlags {
    VSYNC_HINT         = 0x00000040,
    FULLSCREEN_MODE    = 0x00000002,
    WINDOW_RESIZABLE   = 0x00000004,
    WINDOW_UNDECORATED = 0x00000008,
    WINDOW_HIDDEN      = 0x00000080,
    WINDOW_MINIMIZED   = 0x00000200,
    WINDOW_MAXIMIZED   = 0x00000400,
    WINDOW_UNFOCUSED   = 0x00000800,
    WINDOW_TOPMOST     = 0x00001000,
    WINDOW_ALWAYS_RUN  = 0x00000100,
    WINDOW_TRANSPARENT = 0x00000010,
    WINDOW_HIGHDPI     = 0x00002000,
    WINDOW_MOUSE_PASSTHROUGH = 0x00004000,
    BORDERLESS_WINDOWED_MODE = 0x00008000,
    MSAA_4X_HINT       = 0x00000020,
    INTERLACED_HINT    = 0x00010000,
}

pub enum TraceLogLevel {
    ALL = 0,
    TRACE,
    DEBUG,
    INFO,
    WARNING,
    ERROR,
    FATAL,
    NONE,
}

pub enum KeyboardKey {
    NULL            = 0,
    APOSTROPHE      = 39,
    COMMA           = 44,
    MINUS           = 45,
    PERIOD          = 46,
    SLASH           = 47,
    ZERO            = 48,
    ONE             = 49,
    TWO             = 50,
    THREE           = 51,
    FOUR            = 52,
    FIVE            = 53,
    SIX             = 54,
    SEVEN           = 55,
    EIGHT           = 56,
    NINE            = 57,
    SEMICOLON       = 59,
    EQUAL           = 61,
    A               = 65,
    B               = 66,
    C               = 67,
    D               = 68,
    E               = 69,
    F               = 70,
    G               = 71,
    H               = 72,
    I               = 73,
    J               = 74,
    K               = 75,
    L               = 76,
    M               = 77,
    N               = 78,
    O               = 79,
    P               = 80,
    Q               = 81,
    R               = 82,
    S               = 83,
    T               = 84,
    U               = 85,
    V               = 86,
    W               = 87,
    X               = 88,
    Y               = 89,
    Z               = 90,
    LEFT_BRACKET    = 91,
    BACKSLASH       = 92,
    RIGHT_BRACKET   = 93,
    GRAVE           = 96,
    SPACE           = 32,
    ESCAPE          = 256,
    ENTER           = 257,
    TAB             = 258,
    BACKSPACE       = 259,
    INSERT          = 260,
    DELETE          = 261,
    RIGHT           = 262,
    LEFT            = 263,
    DOWN            = 264,
    UP              = 265,
    PAGE_UP         = 266,
    PAGE_DOWN       = 267,
    HOME            = 268,
    END             = 269,
    CAPS_LOCK       = 280,
    SCROLL_LOCK     = 281,
    NUM_LOCK        = 282,
    PRINT_SCREEN    = 283,
    PAUSE           = 284,
    F1              = 290,
    F2              = 291,
    F3              = 292,
    F4              = 293,
    F5              = 294,
    F6              = 295,
    F7              = 296,
    F8              = 297,
    F9              = 298,
    F10             = 299,
    F11             = 300,
    F12             = 301,
    LEFT_SHIFT      = 340,
    LEFT_CONTROL    = 341,
    LEFT_ALT        = 342,
    LEFT_SUPER      = 343,
    RIGHT_SHIFT     = 344,
    RIGHT_CONTROL   = 345,
    RIGHT_ALT       = 346,
    RIGHT_SUPER     = 347,
    KB_MENU         = 348,
    KP_0            = 320,
    KP_1            = 321,
    KP_2            = 322,
    KP_3            = 323,
    KP_4            = 324,
    KP_5            = 325,
    KP_6            = 326,
    KP_7            = 327,
    KP_8            = 328,
    KP_9            = 329,
    KP_DECIMAL      = 330,
    KP_DIVIDE       = 331,
    KP_MULTIPLY     = 332,
    KP_SUBTRACT     = 333,
    KP_ADD          = 334,
    KP_ENTER        = 335,
    KP_EQUAL        = 336,
    BACK            = 4,
    MENU            = 82,
    VOLUME_UP       = 24,
    VOLUME_DOWN     = 25,
}

pub enum MouseButton {
    LEFT,
    RIGHT,
    MIDDLE,
    SIDE,
    EXTRA,
    FORWARD,
    BACK,
}

pub enum MouseCursor {
    DEFAULT,
    ARROW,
    IBEAM,
    CROSSHAIR,
    POINTING_HAND,
    RESIZE_EW,
    RESIZE_NS,
    RESIZE_NWSE,
    RESIZE_NESW,
    RESIZE_ALL,
    NOT_ALLOWED,
}

pub enum GamepadButton {
    UNKNOWN,
    LEFT_FACE_UP,
    LEFT_FACE_RIGHT,
    LEFT_FACE_DOWN,
    LEFT_FACE_LEFT,
    RIGHT_FACE_UP,
    RIGHT_FACE_RIGHT,
    RIGHT_FACE_DOWN,
    RIGHT_FACE_LEFT,
    LEFT_TRIGGER_1,
    LEFT_TRIGGER_2,
    RIGHT_TRIGGER_1,
    RIGHT_TRIGGER_2,
    MIDDLE_LEFT,
    MIDDLE,
    MIDDLE_RIGHT,
    LEFT_THUMB,
    RIGHT_THUMB,
}

pub enum GamepadAxis {
    LEFT_X,
    LEFT_Y,
    RIGHT_X,
    RIGHT_Y,
    LEFT_TRIGGER,
    RIGHT_TRIGGER,
}

pub enum MaterialMapIndex {
    ALBEDO,
    METALNESS,
    NORMAL,
    ROUGHNESS,
    OCCLUSION,
    EMISSION,
    HEIGHT,
    CUBEMAP,
    IRRADIANCE,
    PREFILTER,
    BRDF,
}

pub enum ShaderLocationIndex {
    VERTEX_POSITION,
    VERTEX_TEXCOORD01,
    VERTEX_TEXCOORD02,
    VERTEX_NORMAL,
    VERTEX_TANGENT,
    VERTEX_COLOR,
    MATRIX_MVP,
    MATRIX_VIEW,
    MATRIX_PROJECTION,
    MATRIX_MODEL,
    MATRIX_NORMAL,
    VECTOR_VIEW,
    COLOR_DIFFUSE,
    COLOR_SPECULAR,
    COLOR_AMBIENT,
    MAP_ALBEDO,
    MAP_METALNESS,
    MAP_NORMAL,
    MAP_ROUGHNESS,
    MAP_OCCLUSION,
    MAP_EMISSION,
    MAP_HEIGHT,
    MAP_CUBEMAP,
    MAP_IRRADIANCE,
    MAP_PREFILTER,
    MAP_BRDF,
}

pub enum ShaderUniformDataType {
    FLOAT,
    VEC2,
    VEC3,
    VEC4,
    INT,
    IVEC2,
    IVEC3,
    IVEC4,
    SAMPLER2D,
}

pub enum PixelFormat {
    UNCOMPRESSED_GRAYSCALE = 1,
    UNCOMPRESSED_GRAY_ALPHA,
    UNCOMPRESSED_R5G6B5,
    UNCOMPRESSED_R8G8B8,
    UNCOMPRESSED_R5G5B5A1,
    UNCOMPRESSED_R4G4B4A4,
    UNCOMPRESSED_R8G8B8A8,
    UNCOMPRESSED_R32,
    UNCOMPRESSED_R32G32B32,
    UNCOMPRESSED_R32G32B32A32,
    COMPRESSED_DXT1_RGB,
    COMPRESSED_DXT1_RGBA,
    COMPRESSED_DXT3_RGBA,
    COMPRESSED_DXT5_RGBA,
    COMPRESSED_ETC1_RGB,
    COMPRESSED_ETC2_RGB,
    COMPRESSED_ETC2_EAC_RGBA,
    COMPRESSED_PVRT_RGB,
    COMPRESSED_PVRT_RGBA,
    COMPRESSED_ASTC_4x4_RGBA,
    COMPRESSED_ASTC_8x8_RGBA,
}

pub enum TextureFilter {
    POINT,
    BILINEAR,
    TRILINEAR,
    ANISOTROPIC_4X,
    ANISOTROPIC_8X,
    ANISOTROPIC_16X,
}

pub enum TextureWrap {
    REPEAT,
    CLAMP,
    MIRROR_REPEAT,
    MIRROR_CLAMP,
}

pub enum CubemapLayout {
    AUTO_DETECT,
    LINE_VERTICAL,
    LINE_HORIZONTAL,
    CROSS_THREE_BY_FOUR,
    CROSS_FOUR_BY_THREE,
}

pub enum FontType {
    DEFAULT,
    BITMAP,
    SDF,
}

pub enum BlendMode {
    ALPHA,
    ADDITIVE,
    MULTIPLIED,
    ADD_COLORS,
    SUBTRACT_COLORS,
    ALPHA_PREMULTIPLY,
    CUSTOM,
}

pub enum Gesture {
    NONE,
    TAP,
    DOUBLETAP,
    HOLD,
    DRAG,
    SWIPE_RIGHT,
    SWIPE_LEFT,
    SWIPE_UP,
    SWIPE_DOWN,
    PINCH_IN,
    PINCH_OUT,
}

pub enum CameraMode {
    CUSTOM,
    FREE,
    ORBITAL,
    FIRST_PERSON,
    THIRD_PERSON,
}

pub enum CameraProjection {
    PERSPECTIVE,
    ORTHOGRAPHIC,
}

pub enum NPatchLayout {
    NINE_PATCH,
    THREE_PATCH_VERTICAL,
    THREE_PATCH_HORIZONTAL,
}

pub const TraceLogCallback = fn(logLevel: i32, text: &c_char, args...) void;
pub const LoadFileDataCallback = fn(fileName: &c_char, bytesRead: &mut u32) &c_char;
pub const SaveFileDataCallback = fn(fileName: &c_char, data: &mut void, bytesToWrite: u32) bool;
pub const LoadFileTextCallback = fn(fileName: &c_char) &c_char;
pub const SaveFileTextCallback = fn(fileName: &c_char, text: &mut u8) bool;
pub const AudioCallback = fn(bufferData: &mut void, frames: u32) void;

pub bind fn InitWindow(width: i32, height: i32, title: &c_char) void;
pub bind fn CloseWindow() void;
pub bind fn WindowShouldClose() bool;
pub bind fn IsWindowReady() bool;
pub bind fn IsWindowFullscreen() bool;
pub bind fn IsWindowHidden() bool;
pub bind fn IsWindowMinimized() bool;
pub bind fn IsWindowMaximized() bool;
pub bind fn IsWindowFocused() bool;
pub bind fn IsWindowResized() bool;
pub bind fn IsWindowState(flag: u32) bool;
pub bind fn SetWindowState(flags: u32) void;
pub bind fn ClearWindowState(flags: u32) void;
pub bind fn ToggleFullscreen() void;
pub bind fn MaximizeWindow() void;
pub bind fn MinimizeWindow() void;
pub bind fn RestoreWindow() void;
pub bind fn SetWindowIcon(image: Image) void;
pub bind fn SetWindowTitle(title: &c_char) void;
pub bind fn SetWindowPosition(x: i32, y: i32) void;
pub bind fn SetWindowMonitor(monitor: i32) void;
pub bind fn SetWindowMinSize(width: i32, height: i32) void;
pub bind fn SetWindowSize(width: i32, height: i32) void;
pub bind fn GetWindowHandle() &mut void;
pub bind fn GetScreenWidth() i32;
pub bind fn GetScreenHeight() i32;
pub bind fn GetMonitorCount() i32;
pub bind fn GetCurrentMonitor() i32;
pub bind fn GetMonitorPosition(monitor: i32) Vector2;
pub bind fn GetMonitorWidth(monitor: i32) i32;
pub bind fn GetMonitorHeight(monitor: i32) i32;
pub bind fn GetMonitorPhysicalWidth(monitor: i32) i32;
pub bind fn GetMonitorPhysicalHeight(monitor: i32) i32;
pub bind fn GetMonitorRefreshRate(monitor: i32) i32;
pub bind fn GetWindowPosition() Vector2;
pub bind fn GetWindowScaleDPI() Vector2;
pub bind fn GetMonitorName(monitor: i32) &c_char;
pub bind fn SetClipboardText(text: &c_char) void;
pub bind fn GetClipboardText() &c_char;
pub bind fn ShowCursor() void;
pub bind fn HideCursor() void;
pub bind fn IsCursorHidden() bool;
pub bind fn EnableCursor() void;
pub bind fn DisableCursor() void;
pub bind fn IsCursorOnScreen() bool;
pub bind fn ClearBackground(color: Color) void;
pub bind fn BeginDrawing() void;
pub bind fn EndDrawing() void;
pub bind fn BeginMode2D(camera: Camera2D) void;
pub bind fn EndMode2D() void;
pub bind fn BeginMode3D(camera: Camera3D) void;
pub bind fn EndMode3D() void;
pub bind fn BeginTextureMode(target: RenderTexture2D) void;
pub bind fn EndTextureMode() void;
pub bind fn BeginShaderMode(shader: Shader) void;
pub bind fn EndShaderMode() void;
pub bind fn BeginBlendMode(mode: i32) void;
pub bind fn EndBlendMode() void;
pub bind fn BeginScissorMode(x: i32, y: i32, width: i32, height: i32) void;
pub bind fn EndScissorMode() void;
pub bind fn BeginVrStereoMode(config: VrStereoConfig) void;
pub bind fn EndVrStereoMode() void;
pub bind fn LoadVrStereoConfig(device: VrDeviceInfo) VrStereoConfig;
pub bind fn UnloadVrStereoConfig(config: VrStereoConfig) void;
pub bind fn LoadShader(vsFileName: &c_char, fsFileName: &c_char) Shader;
pub bind fn LoadShaderFromMemory(vsCode: &c_char, fsCode: &c_char) Shader;
pub bind fn GetShaderLocation(shader: Shader, uniformName: &c_char) i32;
pub bind fn GetShaderLocationAttrib(shader: Shader, attribName: &c_char) i32;
pub bind fn SetShaderValue(shader: Shader, locIndex: i32, value: &void, uniformType: i32) void;
pub bind fn SetShaderValueV(shader: Shader, locIndex: i32, value: &void, uniformType: i32, count: i32) void;
pub bind fn SetShaderValueMatrix(shader: Shader, locIndex: i32, mat: Matrix) void;
pub bind fn SetShaderValueTexture(shader: Shader, locIndex: i32, texture: Texture2D) void;
pub bind fn UnloadShader(shader: Shader) void;
pub bind fn GetMouseRay(mousePosition: Vector2, camera: Camera) Ray;
pub bind fn GetCameraMatrix(camera: Camera) Matrix;
pub bind fn GetCameraMatrix2D(camera: Camera2D) Matrix;
pub bind fn GetWorldToScreen(position: Vector3, camera: Camera) Vector2;
pub bind fn GetWorldToScreenEx(position: Vector3, camera: Camera, width: i32, height: i32) Vector2;
pub bind fn GetWorldToScreen2D(position: Vector2, camera: Camera2D) Vector2;
pub bind fn GetScreenToWorld2D(position: Vector2, camera: Camera2D) Vector2;
pub bind fn SetTargetFPS(fps: i32) void;
pub bind fn GetFPS() i32;
pub bind fn GetFrameTime() f32;
pub bind fn GetTime() f64;
pub bind fn GetRandomValue(min: i32, max: i32) i32;
pub bind fn SetRandomSeed(seed: u32) void;
pub bind fn TakeScreenshot(fileName: &c_char) void;
pub bind fn SetConfigFlags(flags: u32) void;
pub bind fn TraceLog(logLevel: i32, text: &c_char, args...) void;
pub bind fn SetTraceLogLevel(logLevel: i32) void;
pub bind fn MemAlloc(size: u32) &mut void;
pub bind fn MemRealloc(ptr: &mut void, size: u32) &mut void;
pub bind fn MemFree(ptr: &mut void) void;
pub bind fn OpenURL(url: &c_char) void;
pub bind fn SetTraceLogCallback(callback: TraceLogCallback) void;
pub bind fn SetLoadFileDataCallback(callback: LoadFileDataCallback) void;
pub bind fn SetSaveFileDataCallback(callback: SaveFileDataCallback) void;
pub bind fn SetLoadFileTextCallback(callback: LoadFileTextCallback) void;
pub bind fn SetSaveFileTextCallback(callback: SaveFileTextCallback) void;
pub bind fn LoadFileData(fileName: &c_char, bytesRead: &mut u32) &c_char;
pub bind fn UnloadFileData(data: &c_char) void;
pub bind fn SaveFileData(fileName: &c_char, data: &mut void, bytesToWrite: u32) bool;
pub bind fn LoadFileText(fileName: &c_char) &c_char;
pub bind fn UnloadFileText(text: &c_char) void;
pub bind fn SaveFileText(fileName: &c_char, text: &mut u8) bool;
pub bind fn FileExists(fileName: &c_char) bool;
pub bind fn DirectoryExists(dirPath: &c_char) bool;
pub bind fn IsFileExtension(fileName: &c_char, ext: &c_char) bool;
pub bind fn GetFileLength(fileName: &c_char) i32;
pub bind fn GetFileExtension(fileName: &c_char) &c_char;
pub bind fn GetFileName(filePath: &c_char) &c_char;
pub bind fn GetFileNameWithoutExt(filePath: &c_char) &c_char;
pub bind fn GetDirectoryPath(filePath: &c_char) &c_char;
pub bind fn GetPrevDirectoryPath(dirPath: &c_char) &c_char;
pub bind fn GetWorkingDirectory() &c_char;
pub bind fn GetApplicationDirectory() &c_char;
pub bind fn ChangeDirectory(dir: &c_char) bool;
pub bind fn IsPathFile(path: &c_char) bool;
pub bind fn LoadDirectoryFiles(dirPath: &c_char) FilePathList;
pub bind fn LoadDirectoryFilesEx(basePath: &c_char, filter: &c_char, scanSubdirs: bool) FilePathList;
pub bind fn UnloadDirectoryFiles(files: FilePathList) void;
pub bind fn IsFileDropped() bool;
pub bind fn LoadDroppedFiles() FilePathList;
pub bind fn UnloadDroppedFiles(files: FilePathList) void;
pub bind fn GetFileModTime(fileName: &c_char) i64;
pub bind fn CompressData(data: &c_char, dataLength: i32, compDataLength: &mut i32) &c_char;
pub bind fn DecompressData(compData: &c_char, compDataLength: i32, dataLength: &mut i32) &c_char;
pub bind fn EncodeDataBase64(data: &c_char, dataLength: i32, outputLength: &mut i32) &c_char;
pub bind fn DecodeDataBase64(data: &c_char, outputLength: &mut i32) &c_char;
pub bind fn LoadAutomationEventList(fileName: &c_char) AutomationEventList;
pub bind fn UnloadAutomationEventList(list: &mut AutomationEventList) void;
pub bind fn ExportAutomationEventList(list: AutomationEventList, fileName: &c_char) bool;
pub bind fn SetAutomationEventList(list: &mut AutomationEventList) void;
pub bind fn SetAutomationEventBaseFrame(frame: i32) void;
pub bind fn StartAutomationEventRecording() void;
pub bind fn StopAutomationEventRecording() void;
pub bind fn PlayAutomationEvent(event: AutomationEvent) void;
pub bind fn IsKeyPressed(key: i32) bool;
pub bind fn IsKeyDown(key: i32) bool;
pub bind fn IsKeyReleased(key: i32) bool;
pub bind fn IsKeyUp(key: i32) bool;
pub bind fn SetExitKey(key: i32) void;
pub bind fn GetKeyPressed() i32;
pub bind fn GetCharPressed() i32;
pub bind fn IsGamepadAvailable(gamepad: i32) bool;
pub bind fn GetGamepadName(gamepad: i32) &c_char;
pub bind fn IsGamepadButtonPressed(gamepad: i32, button: i32) bool;
pub bind fn IsGamepadButtonDown(gamepad: i32, button: i32) bool;
pub bind fn IsGamepadButtonReleased(gamepad: i32, button: i32) bool;
pub bind fn IsGamepadButtonUp(gamepad: i32, button: i32) bool;
pub bind fn GetGamepadButtonPressed() i32;
pub bind fn GetGamepadAxisCount(gamepad: i32) i32;
pub bind fn GetGamepadAxisMovement(gamepad: i32, axis: i32) f32;
pub bind fn SetGamepadMappings(mappings: &c_char) i32;
pub bind fn IsMouseButtonPressed(button: i32) bool;
pub bind fn IsMouseButtonDown(button: i32) bool;
pub bind fn IsMouseButtonReleased(button: i32) bool;
pub bind fn IsMouseButtonUp(button: i32) bool;
pub bind fn GetMouseX() i32;
pub bind fn GetMouseY() i32;
pub bind fn GetMousePosition() Vector2;
pub bind fn GetMouseDelta() Vector2;
pub bind fn SetMousePosition(x: i32, y: i32) void;
pub bind fn SetMouseOffset(offsetX: i32, offsetY: i32) void;
pub bind fn SetMouseScale(scaleX: f32, scaleY: f32) void;
pub bind fn GetMouseWheelMove() f32;
pub bind fn GetMouseWheelMoveV() Vector2;
pub bind fn SetMouseCursor(cursor: i32) void;
pub bind fn GetTouchX() i32;
pub bind fn GetTouchY() i32;
pub bind fn GetTouchPosition(index: i32) Vector2;
pub bind fn GetTouchPointId(index: i32) i32;
pub bind fn GetTouchPointCount() i32;
pub bind fn SetGesturesEnabled(flags: u32) void;
pub bind fn IsGestureDetected(gesture: i32) bool;
pub bind fn GetGestureDetected() i32;
pub bind fn GetGestureHoldDuration() f32;
pub bind fn GetGestureDragVector() Vector2;
pub bind fn GetGestureDragAngle() f32;
pub bind fn GetGesturePinchVector() Vector2;
pub bind fn GetGesturePinchAngle() f32;
pub bind fn SetCameraMode(camera: Camera, mode: i32) void;
pub bind fn UpdateCamera(camera: &mut Camera) void;
pub bind fn SetCameraPanControl(keyPan: i32) void;
pub bind fn SetCameraAltControl(keyAlt: i32) void;
pub bind fn SetCameraSmoothZoomControl(keySmoothZoom: i32) void;
pub bind fn SetCameraMoveControls(keyFront: i32, keyBack: i32, keyRight: i32, keyLeft: i32, keyUp: i32, keyDown: i32) void;
pub bind fn DrawPixel(posX: i32, posY: i32, color: Color) void;
pub bind fn DrawPixelV(position: Vector2, color: Color) void;
pub bind fn DrawLine(startPosX: i32, startPosY: i32, endPosX: i32, endPosY: i32, color: Color) void;
pub bind fn DrawLineV(startPos: Vector2, endPos: Vector2, color: Color) void;
pub bind fn DrawLineEx(startPos: Vector2, endPos: Vector2, thick: f32, color: Color) void;
pub bind fn DrawLineBezier(startPos: Vector2, endPos: Vector2, thick: f32, color: Color) void;
pub bind fn DrawLineBezierQuad(startPos: Vector2, endPos: Vector2, controlPos: Vector2, thick: f32, color: Color) void;
pub bind fn DrawLineBezierCubic(startPos: Vector2, endPos: Vector2, startControlPos: Vector2, endControlPos: Vector2, thick: f32, color: Color) void;
pub bind fn DrawLineStrip(points: &mut Vector2, pointCount: i32, color: Color) void;
pub bind fn DrawCircle(centerX: i32, centerY: i32, radius: f32, color: Color) void;
pub bind fn DrawCircleSector(center: Vector2, radius: f32, startAngle: f32, endAngle: f32, segments: i32, color: Color) void;
pub bind fn DrawCircleSectorLines(center: Vector2, radius: f32, startAngle: f32, endAngle: f32, segments: i32, color: Color) void;
pub bind fn DrawCircleGradient(centerX: i32, centerY: i32, radius: f32, color1: Color, color2: Color) void;
pub bind fn DrawCircleV(center: Vector2, radius: f32, color: Color) void;
pub bind fn DrawCircleLines(centerX: i32, centerY: i32, radius: f32, color: Color) void;
pub bind fn DrawEllipse(centerX: i32, centerY: i32, radiusH: f32, radiusV: f32, color: Color) void;
pub bind fn DrawEllipseLines(centerX: i32, centerY: i32, radiusH: f32, radiusV: f32, color: Color) void;
pub bind fn DrawRing(center: Vector2, innerRadius: f32, outerRadius: f32, startAngle: f32, endAngle: f32, segments: i32, color: Color) void;
pub bind fn DrawRingLines(center: Vector2, innerRadius: f32, outerRadius: f32, startAngle: f32, endAngle: f32, segments: i32, color: Color) void;
pub bind fn DrawRectangle(posX: i32, posY: i32, width: i32, height: i32, color: Color) void;
pub bind fn DrawRectangleV(position: Vector2, size: Vector2, color: Color) void;
pub bind fn DrawRectangleRec(rec: Rectangle, color: Color) void;
pub bind fn DrawRectanglePro(rec: Rectangle, origin: Vector2, rotation: f32, color: Color) void;
pub bind fn DrawRectangleGradientV(posX: i32, posY: i32, width: i32, height: i32, color1: Color, color2: Color) void;
pub bind fn DrawRectangleGradientH(posX: i32, posY: i32, width: i32, height: i32, color1: Color, color2: Color) void;
pub bind fn DrawRectangleGradientEx(rec: Rectangle, col1: Color, col2: Color, col3: Color, col4: Color) void;
pub bind fn DrawRectangleLines(posX: i32, posY: i32, width: i32, height: i32, color: Color) void;
pub bind fn DrawRectangleLinesEx(rec: Rectangle, lineThick: i32, color: Color) void;
pub bind fn DrawRectangleRounded(rec: Rectangle, roundness: f32, segments: i32, color: Color) void;
pub bind fn DrawRectangleRoundedLines(rec: Rectangle, roundness: f32, segments: i32, lineThick: i32, color: Color) void;
pub bind fn DrawTriangle(v1: Vector2, v2: Vector2, v3: Vector2, color: Color) void;
pub bind fn DrawTriangleLines(v1: Vector2, v2: Vector2, v3: Vector2, color: Color) void;
pub bind fn DrawTriangleFan(points: &mut Vector2, pointCount: i32, color: Color) void;
pub bind fn DrawTriangleStrip(points: &mut Vector2, pointCount: i32, color: Color) void;
pub bind fn DrawPoly(center: Vector2, sides: i32, radius: f32, rotation: f32, color: Color) void;
pub bind fn DrawPolyLines(center: Vector2, sides: i32, radius: f32, rotation: f32, color: Color) void;
pub bind fn DrawPolyLinesEx(center: Vector2, sides: i32, radius: f32, rotation: f32, lineThickness: f32, color: Color) void;
pub bind fn CheckCollisionRecs(rec1: Rectangle, rec2: Rectangle) bool;
pub bind fn CheckCollisionCircles(center1: Vector2, radius1: f32, center2: Vector2, radius2: f32) bool;
pub bind fn CheckCollisionCircleRec(center: Vector2, radius: f32, rec: Rectangle) bool;
pub bind fn CheckCollisionPointRec(point: Vector2, rec: Rectangle) bool;
pub bind fn CheckCollisionPointCircle(point: Vector2, center: Vector2, radius: f32) bool;
pub bind fn CheckCollisionPointTriangle(point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2) bool;
pub bind fn CheckCollisionLines(startPos1: Vector2, endPos1: Vector2, startPos2: Vector2, endPos2: Vector2, collisionPoint: &mut Vector2) bool;
pub bind fn CheckCollisionPointLine(point: Vector2, p1: Vector2, p2: Vector2, threshold: i32) bool;
pub bind fn GetCollisionRec(rec1: Rectangle, rec2: Rectangle) Rectangle;
pub bind fn LoadImage(fileName: &c_char) Image;
pub bind fn LoadImageRaw(fileName: &c_char, width: i32, height: i32, format: i32, headerSize: i32) Image;
pub bind fn LoadImageAnim(fileName: &c_char, frames: &mut i32) Image;
pub bind fn LoadImageFromMemory(fileType: &c_char, fileData: &c_char, dataSize: i32) Image;
pub bind fn LoadImageFromTexture(texture: Texture2D) Image;
pub bind fn LoadImageFromScreen() Image;
pub bind fn UnloadImage(image: Image) void;
pub bind fn ExportImage(image: Image, fileName: &c_char) bool;
pub bind fn ExportImageAsCode(image: Image, fileName: &c_char) bool;
pub bind fn GenImageColor(width: i32, height: i32, color: Color) Image;
pub bind fn GenImageGradientV(width: i32, height: i32, top: Color, bottom: Color) Image;
pub bind fn GenImageGradientH(width: i32, height: i32, left: Color, right: Color) Image;
pub bind fn GenImageGradientRadial(width: i32, height: i32, density: f32, inner: Color, outer: Color) Image;
pub bind fn GenImageChecked(width: i32, height: i32, checksX: i32, checksY: i32, col1: Color, col2: Color) Image;
pub bind fn GenImageWhiteNoise(width: i32, height: i32, factor: f32) Image;
pub bind fn GenImageCellular(width: i32, height: i32, tileSize: i32) Image;
pub bind fn ImageCopy(image: Image) Image;
pub bind fn ImageFromImage(image: Image, rec: Rectangle) Image;
pub bind fn ImageText(text: &c_char, fontSize: i32, color: Color) Image;
pub bind fn ImageTextEx(font: Font, text: &c_char, fontSize: f32, spacing: f32, tint: Color) Image;
pub bind fn ImageFormat(image: &mut Image, newFormat: i32) void;
pub bind fn ImageToPOT(image: &mut Image, fill: Color) void;
pub bind fn ImageCrop(image: &mut Image, crop: Rectangle) void;
pub bind fn ImageAlphaCrop(image: &mut Image, threshold: f32) void;
pub bind fn ImageAlphaClear(image: &mut Image, color: Color, threshold: f32) void;
pub bind fn ImageAlphaMask(image: &mut Image, alphaMask: Image) void;
pub bind fn ImageAlphaPremultiply(image: &mut Image) void;
pub bind fn ImageBlurGaussian(image: &mut Image, blurSize: i32) void;
pub bind fn ImageResize(image: &mut Image, newWidth: i32, newHeight: i32) void;
pub bind fn ImageResizeNN(image: &mut Image, newWidth: i32, newHeight: i32) void;
pub bind fn ImageResizeCanvas(image: &mut Image, newWidth: i32, newHeight: i32, offsetX: i32, offsetY: i32, fill: Color) void;
pub bind fn ImageMipmaps(image: &mut Image) void;
pub bind fn ImageDither(image: &mut Image, rBpp: i32, gBpp: i32, bBpp: i32, aBpp: i32) void;
pub bind fn ImageFlipVertical(image: &mut Image) void;
pub bind fn ImageFlipHorizontal(image: &mut Image) void;
pub bind fn ImageRotate(image: &mut Image, degrees: i32) void;
pub bind fn ImageRotateCW(image: &mut Image) void;
pub bind fn ImageRotateCCW(image: &mut Image) void;
pub bind fn ImageColorTint(image: &mut Image, color: Color) void;
pub bind fn ImageColorInvert(image: &mut Image) void;
pub bind fn ImageColorGrayscale(image: &mut Image) void;
pub bind fn ImageColorContrast(image: &mut Image, contrast: f32) void;
pub bind fn ImageColorBrightness(image: &mut Image, brightness: i32) void;
pub bind fn ImageColorReplace(image: &mut Image, color: Color, replace: Color) void;
pub bind fn LoadImageColors(image: Image) &mut Color;
pub bind fn LoadImagePalette(image: Image, maxPaletteSize: i32, colorCount: &mut i32) &mut Color;
pub bind fn UnloadImageColors(colors: &mut Color) void;
pub bind fn UnloadImagePalette(colors: &mut Color) void;
pub bind fn GetImageAlphaBorder(image: Image, threshold: f32) Rectangle;
pub bind fn GetImageColor(image: Image, x: i32, y: i32) Color;
pub bind fn ImageClearBackground(dst: &mut Image, color: Color) void;
pub bind fn ImageDrawPixel(dst: &mut Image, posX: i32, posY: i32, color: Color) void;
pub bind fn ImageDrawPixelV(dst: &mut Image, position: Vector2, color: Color) void;
pub bind fn ImageDrawLine(dst: &mut Image, startPosX: i32, startPosY: i32, endPosX: i32, endPosY: i32, color: Color) void;
pub bind fn ImageDrawLineV(dst: &mut Image, start: Vector2, end: Vector2, color: Color) void;
pub bind fn ImageDrawCircle(dst: &mut Image, centerX: i32, centerY: i32, radius: i32, color: Color) void;
pub bind fn ImageDrawCircleV(dst: &mut Image, center: Vector2, radius: i32, color: Color) void;
pub bind fn ImageDrawRectangle(dst: &mut Image, posX: i32, posY: i32, width: i32, height: i32, color: Color) void;
pub bind fn ImageDrawRectangleV(dst: &mut Image, position: Vector2, size: Vector2, color: Color) void;
pub bind fn ImageDrawRectangleRec(dst: &mut Image, rec: Rectangle, color: Color) void;
pub bind fn ImageDrawRectangleLines(dst: &mut Image, rec: Rectangle, thick: i32, color: Color) void;
pub bind fn ImageDraw(dst: &mut Image, src: Image, srcRec: Rectangle, dstRec: Rectangle, tint: Color) void;
pub bind fn ImageDrawText(dst: &mut Image, text: &c_char, posX: i32, posY: i32, fontSize: i32, color: Color) void;
pub bind fn ImageDrawTextEx(dst: &mut Image, font: Font, text: &c_char, position: Vector2, fontSize: f32, spacing: f32, tint: Color) void;
pub bind fn LoadTexture(fileName: &c_char) Texture2D;
pub bind fn LoadTextureFromImage(image: Image) Texture2D;
pub bind fn LoadTextureCubemap(image: Image, layout: i32) TextureCubemap;
pub bind fn LoadRenderTexture(width: i32, height: i32) RenderTexture2D;
pub bind fn UnloadTexture(texture: Texture2D) void;
pub bind fn UnloadRenderTexture(target: RenderTexture2D) void;
pub bind fn UpdateTexture(texture: Texture2D, pixels: &void) void;
pub bind fn UpdateTextureRec(texture: Texture2D, rec: Rectangle, pixels: &void) void;
pub bind fn GenTextureMipmaps(texture: &mut Texture2D) void;
pub bind fn SetTextureFilter(texture: Texture2D, filter: i32) void;
pub bind fn SetTextureWrap(texture: Texture2D, wrap: i32) void;
pub bind fn DrawTexture(texture: Texture2D, posX: i32, posY: i32, tint: Color) void;
pub bind fn DrawTextureV(texture: Texture2D, position: Vector2, tint: Color) void;
pub bind fn DrawTextureEx(texture: Texture2D, position: Vector2, rotation: f32, scale: f32, tint: Color) void;
pub bind fn DrawTextureRec(texture: Texture2D, source: Rectangle, position: Vector2, tint: Color) void;
pub bind fn DrawTextureQuad(texture: Texture2D, tiling: Vector2, offset: Vector2, quad: Rectangle, tint: Color) void;
pub bind fn DrawTextureTiled(texture: Texture2D, source: Rectangle, dest: Rectangle, origin: Vector2, rotation: f32, scale: f32, tint: Color) void;
pub bind fn DrawTexturePro(texture: Texture2D, source: Rectangle, dest: Rectangle, origin: Vector2, rotation: f32, tint: Color) void;
pub bind fn DrawTextureNPatch(texture: Texture2D, nPatchInfo: NPatchInfo, dest: Rectangle, origin: Vector2, rotation: f32, tint: Color) void;
pub bind fn Fade(color: Color, alpha: f32) Color;
pub bind fn ColorToInt(color: Color) i32;
pub bind fn ColorNormalize(color: Color) Vector4;
pub bind fn ColorFromNormalized(normalized: Vector4) Color;
pub bind fn ColorToHSV(color: Color) Vector3;
pub bind fn ColorFromHSV(hue: f32, saturation: f32, value: f32) Color;
pub bind fn ColorAlpha(color: Color, alpha: f32) Color;
pub bind fn ColorAlphaBlend(dst: Color, src: Color, tint: Color) Color;
pub bind fn GetColor(hexValue: u32) Color;
pub bind fn GetPixelColor(srcPtr: &mut void, format: i32) Color;
pub bind fn SetPixelColor(dstPtr: &mut void, color: Color, format: i32) void;
pub bind fn GetPixelDataSize(width: i32, height: i32, format: i32) i32;
pub bind fn GetFontDefault() Font;
pub bind fn LoadFont(fileName: &c_char) Font;
pub bind fn LoadFontEx(fileName: &c_char, fontSize: i32, fontChars: &mut i32, glyphCount: i32) Font;
pub bind fn LoadFontFromImage(image: Image, key: Color, firstChar: i32) Font;
pub bind fn LoadFontFromMemory(fileType: &c_char, fileData: &c_char, dataSize: i32, fontSize: i32, fontChars: &mut i32, glyphCount: i32) Font;
pub bind fn LoadFontData(fileData: &c_char, dataSize: i32, fontSize: i32, fontChars: &mut i32, glyphCount: i32, type: i32) &mut GlyphInfo;
pub bind fn GenImageFontAtlas(chars: &GlyphInfo, recs: &mut &mut Rectangle, glyphCount: i32, fontSize: i32, padding: i32, packMethod: i32) Image;
pub bind fn UnloadFontData(chars: &mut GlyphInfo, glyphCount: i32) void;
pub bind fn UnloadFont(font: Font) void;
pub bind fn ExportFontAsCode(font: Font, fileName: &c_char) bool;
pub bind fn DrawFPS(posX: i32, posY: i32) void;
pub bind fn DrawText(text: &c_char, posX: i32, posY: i32, fontSize: i32, color: Color) void;
pub bind fn DrawTextEx(font: Font, text: &c_char, position: Vector2, fontSize: f32, spacing: f32, tint: Color) void;
pub bind fn DrawTextPro(font: Font, text: &c_char, position: Vector2, origin: Vector2, rotation: f32, fontSize: f32, spacing: f32, tint: Color) void;
pub bind fn DrawTextCodepoint(font: Font, codepoint: i32, position: Vector2, fontSize: f32, tint: Color) void;
pub bind fn DrawTextCodepoints(font: Font, codepoints: &i32, count: i32, position: Vector2, fontSize: f32, spacing: f32, tint: Color) void;
pub bind fn MeasureText(text: &c_char, fontSize: i32) i32;
pub bind fn MeasureTextEx(font: Font, text: &c_char, fontSize: f32, spacing: f32) Vector2;
pub bind fn GetGlyphIndex(font: Font, codepoint: i32) i32;
pub bind fn GetGlyphInfo(font: Font, codepoint: i32) GlyphInfo;
pub bind fn GetGlyphAtlasRec(font: Font, codepoint: i32) Rectangle;
pub bind fn LoadCodepoints(text: &c_char, count: &mut i32) &mut i32;
pub bind fn UnloadCodepoints(codepoints: &mut i32) void;
pub bind fn GetCodepointCount(text: &c_char) i32;
pub bind fn GetCodepoint(text: &c_char, bytesProcessed: &mut i32) i32;
pub bind fn CodepointToUTF8(codepoint: i32, byteSize: &mut i32) &c_char;
pub bind fn TextCodepointsToUTF8(codepoints: &i32, length: i32) &mut u8;
pub bind fn TextCopy(dst: &mut u8, src: &c_char) i32;
pub bind fn TextIsEqual(text1: &c_char, text2: &c_char) bool;
pub bind fn TextLength(text: &c_char) u32;
pub bind fn TextFormat(text: &c_char, args...) &c_char;
pub bind fn TextSubtext(text: &c_char, position: i32, length: i32) &mut u8;
pub bind fn TextReplace(text: &mut u8, replace: &c_char, by: &c_char) &mut u8;
pub bind fn TextInsert(text: &c_char, insert: &c_char, position: i32) &mut u8;
pub bind fn TextJoin(textList: &&c_char, count: i32, joiner: &c_char) &mut u8;
pub bind fn TextSplit(text: &c_char, delimiter: u8, count: &mut i32) &mut &mut u8;
pub bind fn TextAppend(text: &mut u8, append: &c_char, position: &mut i32) void;
pub bind fn TextFindIndex(text: &c_char, find: &c_char) i32;
pub bind fn TextToUpper(text: &c_char) &c_char;
pub bind fn TextToLower(text: &c_char) &c_char;
pub bind fn TextToPascal(text: &c_char) &c_char;
pub bind fn TextToInteger(text: &c_char) i32;
pub bind fn DrawLine3D(startPos: Vector3, endPos: Vector3, color: Color) void;
pub bind fn DrawPoint3D(position: Vector3, color: Color) void;
pub bind fn DrawCircle3D(center: Vector3, radius: f32, rotationAxis: Vector3, rotationAngle: f32, color: Color) void;
pub bind fn DrawTriangle3D(v1: Vector3, v2: Vector3, v3: Vector3, color: Color) void;
pub bind fn DrawTriangleStrip3D(points: &mut Vector3, pointCount: i32, color: Color) void;
pub bind fn DrawCube(position: Vector3, width: f32, height: f32, length: f32, color: Color) void;
pub bind fn DrawCubeV(position: Vector3, size: Vector3, color: Color) void;
pub bind fn DrawCubeWires(position: Vector3, width: f32, height: f32, length: f32, color: Color) void;
pub bind fn DrawCubeWiresV(position: Vector3, size: Vector3, color: Color) void;
pub bind fn DrawCubeTexture(texture: Texture2D, position: Vector3, width: f32, height: f32, length: f32, color: Color) void;
pub bind fn DrawCubeTextureRec(texture: Texture2D, source: Rectangle, position: Vector3, width: f32, height: f32, length: f32, color: Color) void;
pub bind fn DrawSphere(centerPos: Vector3, radius: f32, color: Color) void;
pub bind fn DrawSphereEx(centerPos: Vector3, radius: f32, rings: i32, slices: i32, color: Color) void;
pub bind fn DrawSphereWires(centerPos: Vector3, radius: f32, rings: i32, slices: i32, color: Color) void;
pub bind fn DrawCylinder(position: Vector3, radiusTop: f32, radiusBottom: f32, height: f32, slices: i32, color: Color) void;
pub bind fn DrawCylinderEx(startPos: Vector3, endPos: Vector3, startRadius: f32, endRadius: f32, sides: i32, color: Color) void;
pub bind fn DrawCylinderWires(position: Vector3, radiusTop: f32, radiusBottom: f32, height: f32, slices: i32, color: Color) void;
pub bind fn DrawCylinderWiresEx(startPos: Vector3, endPos: Vector3, startRadius: f32, endRadius: f32, sides: i32, color: Color) void;
pub bind fn DrawPlane(centerPos: Vector3, size: Vector2, color: Color) void;
pub bind fn DrawRay(ray: Ray, color: Color) void;
pub bind fn DrawGrid(slices: i32, spacing: f32) void;
pub bind fn LoadModel(fileName: &c_char) Model;
pub bind fn LoadModelFromMesh(mesh: Mesh) Model;
pub bind fn UnloadModel(model: Model) void;
pub bind fn UnloadModelKeepMeshes(model: Model) void;
pub bind fn GetModelBoundingBox(model: Model) BoundingBox;
pub bind fn DrawModel(model: Model, position: Vector3, scale: f32, tint: Color) void;
pub bind fn DrawModelEx(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: f32, scale: Vector3, tint: Color) void;
pub bind fn DrawModelWires(model: Model, position: Vector3, scale: f32, tint: Color) void;
pub bind fn DrawModelWiresEx(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: f32, scale: Vector3, tint: Color) void;
pub bind fn DrawBoundingBox(box: BoundingBox, color: Color) void;
pub bind fn DrawBillboard(camera: Camera, texture: Texture2D, position: Vector3, size: f32, tint: Color) void;
pub bind fn DrawBillboardRec(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, size: Vector2, tint: Color) void;
pub bind fn DrawBillboardPro(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, up: Vector3, size: Vector2, origin: Vector2, rotation: f32, tint: Color) void;
pub bind fn UploadMesh(mesh: &mut Mesh, dynamic: bool) void;
pub bind fn UpdateMeshBuffer(mesh: Mesh, index: i32, data: &void, dataSize: i32, offset: i32) void;
pub bind fn UnloadMesh(mesh: Mesh) void;
pub bind fn DrawMesh(mesh: Mesh, material: Material, transform: Matrix) void;
pub bind fn DrawMeshInstanced(mesh: Mesh, material: Material, transforms: &Matrix, instances: i32) void;
pub bind fn GetMeshBoundingBox(mesh: Mesh) BoundingBox;
pub bind fn GenMeshTangents(mesh: &mut Mesh) void;
pub bind fn GenMeshBinormals(mesh: &mut Mesh) void;
pub bind fn GenMeshPoly(sides: i32, radius: f32) Mesh;
pub bind fn GenMeshPlane(width: f32, length: f32, resX: i32, resZ: i32) Mesh;
pub bind fn GenMeshCube(width: f32, height: f32, length: f32) Mesh;
pub bind fn GenMeshSphere(radius: f32, rings: i32, slices: i32) Mesh;
pub bind fn GenMeshHemiSphere(radius: f32, rings: i32, slices: i32) Mesh;
pub bind fn GenMeshCylinder(radius: f32, height: f32, slices: i32) Mesh;
pub bind fn GenMeshCone(radius: f32, height: f32, slices: i32) Mesh;
pub bind fn GenMeshTorus(radius: f32, size: f32, radSeg: i32, sides: i32) Mesh;
pub bind fn GenMeshKnot(radius: f32, size: f32, radSeg: i32, sides: i32) Mesh;
pub bind fn GenMeshHeightmap(heightmap: Image, size: Vector3) Mesh;
pub bind fn GenMeshCubicmap(cubicmap: Image, cubeSize: Vector3) Mesh;
pub bind fn LoadMaterials(fileName: &c_char, materialCount: &mut i32) &mut Material;
pub bind fn GetMaterialDefault() Material;
pub bind fn UnloadMaterial(material: Material) void;
pub bind fn SetMaterialTexture(material: &mut Material, mapType: i32, texture: Texture2D) void;
pub bind fn SetModelMeshMaterial(model: &mut Model, meshId: i32, materialId: i32) void;
pub bind fn LoadModelAnimations(fileName: &c_char, animCount: &mut u32) &mut ModelAnimation;
pub bind fn UpdateModelAnimation(model: Model, anim: ModelAnimation, frame: i32) void;
pub bind fn UnloadModelAnimation(anim: ModelAnimation) void;
pub bind fn UnloadModelAnimations(animations: &mut ModelAnimation, animCount: u32) void;
pub bind fn IsModelAnimationValid(model: Model, anim: ModelAnimation) bool;
pub bind fn CheckCollisionSpheres(center1: Vector3, radius1: f32, center2: Vector3, radius2: f32) bool;
pub bind fn CheckCollisionBoxes(box1: BoundingBox, box2: BoundingBox) bool;
pub bind fn CheckCollisionBoxSphere(box: BoundingBox, center: Vector3, radius: f32) bool;
pub bind fn GetRayCollisionSphere(ray: Ray, center: Vector3, radius: f32) RayCollision;
pub bind fn GetRayCollisionBox(ray: Ray, box: BoundingBox) RayCollision;
pub bind fn GetRayCollisionMesh(ray: Ray, mesh: Mesh, transform: Matrix) RayCollision;
pub bind fn GetRayCollisionTriangle(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3) RayCollision;
pub bind fn GetRayCollisionQuad(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3, p4: Vector3) RayCollision;
pub bind fn InitAudioDevice() void;
pub bind fn CloseAudioDevice() void;
pub bind fn IsAudioDeviceReady() bool;
pub bind fn SetMasterVolume(volume: f32) void;
pub bind fn LoadWave(fileName: &c_char) Wave;
pub bind fn LoadWaveFromMemory(fileType: &c_char, fileData: &c_char, dataSize: i32) Wave;
pub bind fn LoadSound(fileName: &c_char) Sound;
pub bind fn LoadSoundFromWave(wave: Wave) Sound;
pub bind fn UpdateSound(sound: Sound, data: &void, sampleCount: i32) void;
pub bind fn UnloadWave(wave: Wave) void;
pub bind fn UnloadSound(sound: Sound) void;
pub bind fn ExportWave(wave: Wave, fileName: &c_char) bool;
pub bind fn ExportWaveAsCode(wave: Wave, fileName: &c_char) bool;
pub bind fn PlaySound(sound: Sound) void;
pub bind fn StopSound(sound: Sound) void;
pub bind fn PauseSound(sound: Sound) void;
pub bind fn ResumeSound(sound: Sound) void;
pub bind fn PlaySoundMulti(sound: Sound) void;
pub bind fn StopSoundMulti() void;
pub bind fn GetSoundsPlaying() i32;
pub bind fn IsSoundPlaying(sound: Sound) bool;
pub bind fn SetSoundVolume(sound: Sound, volume: f32) void;
pub bind fn SetSoundPitch(sound: Sound, pitch: f32) void;
pub bind fn SetSoundPan(sound: Sound, pan: f32) void;
pub bind fn WaveFormat(wave: &mut Wave, sampleRate: i32, sampleSize: i32, channels: i32) void;
pub bind fn WaveCopy(wave: Wave) Wave;
pub bind fn WaveCrop(wave: &mut Wave, initSample: i32, finalSample: i32) void;
pub bind fn LoadWaveSamples(wave: Wave) &mut f32;
pub bind fn UnloadWaveSamples(samples: &mut f32) void;
pub bind fn LoadMusicStream(fileName: &c_char) Music;
pub bind fn LoadMusicStreamFromMemory(fileType: &c_char, data: &c_char, dataSize: i32) Music;
pub bind fn UnloadMusicStream(music: Music) void;
pub bind fn PlayMusicStream(music: Music) void;
pub bind fn IsMusicStreamPlaying(music: Music) bool;
pub bind fn UpdateMusicStream(music: Music) void;
pub bind fn StopMusicStream(music: Music) void;
pub bind fn PauseMusicStream(music: Music) void;
pub bind fn ResumeMusicStream(music: Music) void;
pub bind fn SeekMusicStream(music: Music, position: f32) void;
pub bind fn SetMusicVolume(music: Music, volume: f32) void;
pub bind fn SetMusicPitch(music: Music, pitch: f32) void;
pub bind fn SetMusicPan(music: Music, pan: f32) void;
pub bind fn GetMusicTimeLength(music: Music) f32;
pub bind fn GetMusicTimePlayed(music: Music) f32;
pub bind fn LoadAudioStream(sampleRate: u32, sampleSize: u32, channels: u32) AudioStream;
pub bind fn UnloadAudioStream(stream: AudioStream) void;
pub bind fn UpdateAudioStream(stream: AudioStream, data: &void, frameCount: i32) void;
pub bind fn IsAudioStreamProcessed(stream: AudioStream) bool;
pub bind fn PlayAudioStream(stream: AudioStream) void;
pub bind fn PauseAudioStream(stream: AudioStream) void;
pub bind fn ResumeAudioStream(stream: AudioStream) void;
pub bind fn IsAudioStreamPlaying(stream: AudioStream) bool;
pub bind fn StopAudioStream(stream: AudioStream) void;
pub bind fn SetAudioStreamVolume(stream: AudioStream, volume: f32) void;
pub bind fn SetAudioStreamPitch(stream: AudioStream, pitch: f32) void;
pub bind fn SetAudioStreamPan(stream: AudioStream, pan: f32) void;
pub bind fn SetAudioStreamBufferSizeDefault(size: i32) void;
pub bind fn SetAudioStreamCallback(stream: AudioStream, callback: AudioCallback) void;
pub bind fn AttachAudioStreamProcessor(stream: AudioStream, processor: AudioCallback) void;
pub bind fn DetachAudioStreamProcessor(stream: AudioStream, processor: AudioCallback) void;

const LIGHTGRAY = Color { r: 200, g: 200, b: 200, a: 255 };
const GRAY = Color { r: 130, g: 130, b: 130, a: 255 };
const DARKGRAY = Color { r: 80, g: 80, b: 80, a: 255 };
const YELLOW = Color { r: 253, g: 249, b: 0, a: 255 };
const GOLD = Color { r: 255, g: 203, b: 0, a: 255 };
const ORANGE = Color { r: 255, g: 161, b: 0, a: 255 };
const PINK = Color { r: 255, g: 109, b: 194, a: 255 };
const RED = Color { r: 230, g: 41, b: 55, a: 255 };
const MAROON = Color { r: 190, g: 33, b: 55, a: 255 };
const GREEN = Color { r: 0, g: 228, b: 48, a: 255 };
const LIME = Color { r: 0, g: 158, b: 47, a: 255 };
const DARKGREEN = Color { r: 0, g: 117, b: 44, a: 255 };
const SKYBLUE = Color { r: 102, g: 191, b: 255, a: 255 };
const BLUE = Color { r: 0, g: 121, b: 241, a: 255 };
const DARKBLUE = Color { r: 0, g: 82, b: 172, a: 255 };
const PURPLE = Color { r: 200, g: 122, b: 255, a: 255 };
const VIOLET = Color { r: 135, g: 60, b: 190, a: 255 };
const DARKPURPLE = Color { r: 112, g: 31, b: 126, a: 255 };
const BEIGE = Color { r: 211, g: 176, b: 131, a: 255 };
const BROWN = Color { r: 127, g: 106, b: 79, a: 255 };
const DARKBROWN = Color { r: 76, g: 63, b: 47, a: 255 };
const WHITE = Color { r: 255, g: 255, b: 255, a: 255 };
const BLACK = Color { r: 0, g: 0, b: 0, a: 255 };
const BLANK = Color { r: 0, g: 0, b: 0, a: 0 };
const MAGENTA = Color { r: 255, g: 0, b: 255, a: 255 };
const RAYWHITE = Color { r: 245, g: 245, b: 245, a: 255 };
